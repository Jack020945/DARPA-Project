{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"sym-cps \u00b6 Symbiotic Design for Cyber Physical Systems Project descriptin available here Installation \u00b6 We use pdm to most of the dependencies, and conda . Make sure they are installed on your system. To install the environment, simply run: make setup The setup script will: * Install all the dependecies via pdm * Create a new conda environment and isntall the conda dependencies Once the dependencies are installed you can activate the environments and launching python scripts. Activating conda enviornment \u00b6 conda activate ./.venv Launch examples \u00b6 python src/sym_cps/examples/library.py python src/sym_cps/examples/designs.py python src/sym_cps/examples/topology.py Check the example folder for more examples. Look at the code in the examples to understand the APIs available. Documentation \u00b6 make docs-serve Troubleshooting \u00b6 Note If it fails for some reason, you'll need to install PDM manually. You can install it with: python3 -m pip install --user pipx pipx install pdm Now you can try running make setup again. Note Apple Silicon Make sure that you are running a x86 terminal. You can run x86 terminal commands with Apple\u2019s Rosetta 2 by launching: arch -x86_64 /bin/bash Note Conda for Mac with Apple Silicon Some of the packages in conda do not support arm64 architecture. To install all the dependencies correctly on a Mac with Apple Silicon, make sure that you are running conda for x86_64 architecture. You can install miniconda for MacOSX x86_64 by running the following commands curl -L https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-x86_64.sh > Miniconda3-latest-MacOSX-x86_64.sh sh Miniconda3-latest-MacOSX-x86_64.sh Note Working with PEP 582 With PEP 582, dependencies will be installed into pypackages directory under the project root. With PEP 582 enabled globally, you can also use the project interpreter to run scripts directly. Check pdm documentation on PEP 582. To configure VSCode to support PEP 582, open .vscode/settings.json (create one if it does not exist) and add the following entries: { \"python.autoComplete.extraPaths\" : [ \"__pypackages__/3.10/lib\" ], \"python.analysis.extraPaths\" : [ \"__pypackages__/3.10/lib\" ] } Note VSCode and Apple Silicon To run a x86 terminal by default in VSCode. Add the following to your settings.json ```json \"terminal.integrated.profiles.osx\": { \"x86 bash\": { \"path\": \"/usr/bin/arch\", \"args\": [\"-arch\", \"x86_64\", \"/bin/bash\"] } }, \"terminal.integrated.defaultProfile.osx\": \"x86 bash\" NOTE: PyCharm and Apple Silicon Go to Preferences/Tools/Terminal and set the shell path to be: ```bash env /usr/bin/arch -x86_64 /bin/zsh --login License \u00b6 MIT Features and Credits \u00b6 Fully typed with annotations and checked with mypy, PEP561 compatible","title":"Overview"},{"location":"#sym-cps","text":"Symbiotic Design for Cyber Physical Systems Project descriptin available here","title":"sym-cps"},{"location":"#installation","text":"We use pdm to most of the dependencies, and conda . Make sure they are installed on your system. To install the environment, simply run: make setup The setup script will: * Install all the dependecies via pdm * Create a new conda environment and isntall the conda dependencies Once the dependencies are installed you can activate the environments and launching python scripts.","title":"Installation"},{"location":"#activating-conda-enviornment","text":"conda activate ./.venv","title":"Activating conda enviornment"},{"location":"#launch-examples","text":"python src/sym_cps/examples/library.py python src/sym_cps/examples/designs.py python src/sym_cps/examples/topology.py Check the example folder for more examples. Look at the code in the examples to understand the APIs available.","title":"Launch examples"},{"location":"#documentation","text":"make docs-serve","title":"Documentation"},{"location":"#troubleshooting","text":"Note If it fails for some reason, you'll need to install PDM manually. You can install it with: python3 -m pip install --user pipx pipx install pdm Now you can try running make setup again. Note Apple Silicon Make sure that you are running a x86 terminal. You can run x86 terminal commands with Apple\u2019s Rosetta 2 by launching: arch -x86_64 /bin/bash Note Conda for Mac with Apple Silicon Some of the packages in conda do not support arm64 architecture. To install all the dependencies correctly on a Mac with Apple Silicon, make sure that you are running conda for x86_64 architecture. You can install miniconda for MacOSX x86_64 by running the following commands curl -L https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-x86_64.sh > Miniconda3-latest-MacOSX-x86_64.sh sh Miniconda3-latest-MacOSX-x86_64.sh Note Working with PEP 582 With PEP 582, dependencies will be installed into pypackages directory under the project root. With PEP 582 enabled globally, you can also use the project interpreter to run scripts directly. Check pdm documentation on PEP 582. To configure VSCode to support PEP 582, open .vscode/settings.json (create one if it does not exist) and add the following entries: { \"python.autoComplete.extraPaths\" : [ \"__pypackages__/3.10/lib\" ], \"python.analysis.extraPaths\" : [ \"__pypackages__/3.10/lib\" ] } Note VSCode and Apple Silicon To run a x86 terminal by default in VSCode. Add the following to your settings.json ```json \"terminal.integrated.profiles.osx\": { \"x86 bash\": { \"path\": \"/usr/bin/arch\", \"args\": [\"-arch\", \"x86_64\", \"/bin/bash\"] } }, \"terminal.integrated.defaultProfile.osx\": \"x86 bash\" NOTE: PyCharm and Apple Silicon Go to Preferences/Tools/Terminal and set the shell path to be: ```bash env /usr/bin/arch -x86_64 /bin/zsh --login","title":"Troubleshooting"},{"location":"#license","text":"MIT","title":"License"},{"location":"#features-and-credits","text":"Fully typed with annotations and checked with mypy, PEP561 compatible","title":"Features and Credits"},{"location":"changelog/","text":"Changelog \u00b6 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"contributing/","text":"Contributing \u00b6 Contributions are welcome, and they are greatly appreciated! Tasks \u00b6 This project uses duty to run tasks. A Makefile is also provided. Once the project is installed ( make setup ), run make help to see all available tasks Development \u00b6 We use pdm to manage the dependencies. Use pdm add to install new packages. Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) if you updated the documentation or the project dependencies: run make docs-serve go to http://localhost:8000 and check that everything looks good Activate Pre-Commit Hooks pre-commit install","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated!","title":"Contributing"},{"location":"contributing/#tasks","text":"This project uses duty to run tasks. A Makefile is also provided. Once the project is installed ( make setup ), run make help to see all available tasks","title":"Tasks"},{"location":"contributing/#development","text":"We use pdm to manage the dependencies. Use pdm add to install new packages. Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) if you updated the documentation or the project dependencies: run make docs-serve go to http://localhost:8000 and check that everything looks good Activate Pre-Commit Hooks pre-commit install","title":"Development"},{"location":"credits/","text":"These projects were used to build sym-cps . Thank you! python | pdm | copier-pdm Runtime dependencies \u00b6 Project Summary Version (accepted) Version (last resolved) License cycler Composable style cycles >=0.10 0.11.0 BSD dill serialize all of python >=0.3.5.1 0.3.5.1 3-clause BSD fonttools Tools to manipulate font files >=4.22.0 4.37.1 MIT igraph High performance graph data structures and algorithms ==0.10.0 0.10.0 GNU General Public License (GPL) kiwisolver A fast implementation of the Cassowary constraint solver >=1.0.1 1.4.4 BSD License matplotlib Python plotting package >=3.5.3 3.5.3 PSF networkx Python package for creating and manipulating graphs and networks >=2.8.6 2.8.6 BSD License numpy NumPy is the fundamental package for array computing with Python. >=1.17 1.23.3 BSD packaging Core utilities for Python packages >=20.0 21.3 BSD-2-Clause or Apache-2.0 pillow Python Imaging Library (Fork) >=6.2.0 9.2.0 HPND pyparsing pyparsing module - Classes and methods to define and execute parsing grammars >=2.2.1 3.0.9 MIT License python-dateutil Extensions to the standard Python datetime module >=2.7 2.8.2 Dual License python-igraph High performance graph data structures and algorithms (legacy package) >=0.10.0 0.10.0 GNU General Public License (GPL) scipy SciPy: Scientific Library for Python >=1.9.1 1.9.1 BSD six Python 2 and 3 compatibility utilities >=1.5 1.16.0 MIT texttable module for creating simple ASCII tables >=1.6.2 1.6.4 MIT Development dependencies \u00b6 Project Summary Version (accepted) Version (last resolved) License ansimarkup Produce colored terminal text with an xml-like markup ~=1.4 1.5.0 Revised BSD License astor Read/rewrite/write Python ASTs >=0.8 0.8.1 BSD-3-Clause attrs Classes Without Boilerplate >=19.2.0 22.1.0 MIT autoflake Removes unused imports and unused variables >=1.4 1.5.3 MIT bandit Security oriented static analyser for python code. >=1.7.3 1.7.4 Apache-2.0 license black The uncompromising code formatter. >=21.10b0 22.8.0 MIT certifi Python package for providing Mozilla's CA Bundle. >=2017.4.17 2022.6.15.1 MPL-2.0 charset-normalizer The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet. <3,>=2 2.1.1 MIT click Composable command line interface toolkit >=8.0.0 8.1.3 BSD-3-Clause colorama Cross-platform colored terminal text. ; platform_system == \"Windows\" 0.4.5 BSD coverage Code coverage measurement for Python [toml]>=5.2.1 6.4.4 Apache 2.0 darglint A utility for ensuring Google-style docstrings stay up to date with the source code. >=1.8 1.8.1 MIT dparse A parser for Python dependency files >=0.5.1 0.6.0 MIT license duty A simple task runner. >=0.7 0.7.0 Other/Proprietary License execnet execnet: rapid multi-Python deployment >=1.1 1.9.0 MIT failprint Run a command, print its output only if it fails. ~=0.8 0.8.0 Other/Proprietary License flake8 the modular source code checker: pep8 pyflakes and co <4 3.9.2 MIT flake8-bandit Automated security testing with bandit and flake8. >=2.1 3.0.0 MIT flake8-black flake8 plugin to call black as a code style validator >=0.2 0.3.3 MIT flake8-bugbear A plugin for flake8 finding likely bugs and design problems in your program. Contains warnings that don't belong in pyflakes and pycodestyle. >=21.9 22.9.11 MIT flake8-builtins Check for python builtins being used as variables or parameters. >=1.5 1.5.3 GPL version 2 flake8-comprehensions A flake8 plugin to help you write better list/set/dict comprehensions. >=3.7 3.10.0 MIT flake8-docstrings Extension for flake8 which uses pydocstyle to check docstrings >=1.6 1.6.0 MIT License flake8-plugin-utils The package provides base classes and utils for flake8 plugin writing <2.0.0,>=1.3.2 1.3.2 MIT flake8-polyfill Polyfill package for Flake8 plugins 1.0.2 MIT flake8-pytest-style A flake8 plugin checking common style issues or inconsistencies with pytest-based tests. >=1.5 1.6.0 MIT flake8-string-format string format checker, plugin for flake8 >=0.3 0.3.0 MIT License flake8-tidy-imports A flake8 plugin that helps you write tidier imports. >=4.5 4.8.0 MIT flake8-variables-names A flake8 extension that helps to make more readable variables names >=0.0 0.0.5 MIT ghp-import Copy your docs directly to the gh-pages branch. >=1.0 2.1.0 Apache Software License git-changelog Automatic Changelog generator using Jinja2 templates. >=0.4 0.5.0 Other/Proprietary License gitdb Git Object Database <5,>=4.0.1 4.0.9 BSD License gitpython GitPython is a python library used to interact with Git repositories >=1.0.1 3.1.27 BSD griffe Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. >=0.11.1 0.22.1 ISC idna Internationalized Domain Names in Applications (IDNA) <4,>=2.5 3.3 BSD-3-Clause importlib-metadata Read metadata from Python packages >=4.3 4.12.0 Apache Software License iniconfig iniconfig: brain-dead simple config-ini parsing 1.1.1 MIT License isort A Python utility / library to sort Python imports. >=5.10 5.10.1 MIT jinja2 A very fast and expressive template engine. <4,>=2.11 3.1.2 BSD-3-Clause markdown Python implementation of Markdown. <4.0,>=3.3 3.3.7 BSD License markdown-callouts Markdown extension: a classier syntax for admonitions >=0.2 0.2.0 MIT markdown-exec Utilities to execute code blocks in Markdown files. >=0.5 0.7.2 ISC markupsafe Safely add untrusted strings to HTML/XML markup. >=2.0 2.1.1 BSD-3-Clause mccabe McCabe checker, plugin for flake8 <0.7.0,>=0.6.0 0.6.1 Expat license mergedeep A deep merge function for \ud83d\udc0d. >=1.3.4 1.3.4 MIT License mkdocs Project documentation with Markdown. >=1.3 1.3.1 BSD mkdocs-coverage MkDocs plugin to integrate your coverage HTML report into your site. >=0.2 0.2.5 ISC License (ISCL) mkdocs-gen-files MkDocs plugin to programmatically generate documentation pages during the build >=0.3 0.4.0 MIT mkdocs-literate-nav MkDocs plugin to specify the navigation in Markdown instead of YAML >=0.4 0.4.1 MIT mkdocs-material Documentation that simply works >=7.3 8.4.4 MIT mkdocs-material-extensions Extension pack for Python Markdown. >=1.0.3 1.0.3 MIT License mkdocs-section-index MkDocs plugin to allow clickable sections that lead to an index page >=0.3 0.3.4 MIT mkdocstrings Automatic documentation from sources, for MkDocs. [python]>=0.18 0.19.0 ISC License (ISCL) mkdocstrings-python A Python handler for mkdocstrings. >=0.5.2 0.7.1 ISC mypy Optional static typing for Python >=0.910 0.971 MIT License mypy-extensions Experimental type system extensions for programs checked with the mypy typechecker. >=0.4.3 0.4.3 MIT License packaging Core utilities for Python packages >=20.5 21.3 BSD-2-Clause or Apache-2.0 pathspec Utility library for gitignore style pattern matching of file paths. >=0.9.0 0.10.1 MPL 2.0 pbr Python Build Reasonableness !=2.1.0,>=2.0.0 5.10.0 Apache Software License pep8-naming Check PEP-8 naming conventions, plugin for flake8 >=0.12 0.13.2 Expat license platformdirs A small Python module for determining appropriate platform-specific dirs, e.g. a \"user data dir\". >=2 2.5.2 MIT License pluggy plugin and hook calling mechanisms for python <2.0,>=0.12 1.0.0 MIT ptyprocess Run a subprocess in a pseudo terminal ~=0.6; sys_platform != \"win32\" 0.7.0 ISC License (ISCL) py library with cross-python path, ini-parsing, io, code, log facilities >=1.8.2 1.11.0 MIT license pycodestyle Python style guide checker <2.8.0,>=2.7.0 2.7.0 Expat license pydocstyle Python docstring style checker >=2.1 6.1.1 MIT pyflakes passive checker of Python programs >=1.1.0 2.3.1 MIT pygments Pygments is a syntax highlighting package written in Python. >=2.12 2.13.0 BSD License pymdown-extensions Extension pack for Python Markdown. >=9 9.5 MIT License pyparsing pyparsing module - Classes and methods to define and execute parsing grammars !=3.0.5,>=2.0.2 3.0.9 MIT License pytest pytest: simple powerful testing with Python >=6.2 7.1.3 MIT pytest-cov Pytest plugin for measuring coverage. >=3.0 3.0.0 MIT pytest-forked run tests in isolated forked subprocesses 1.4.0 MIT pytest-randomly Pytest plugin to randomly order tests and control random.seed. >=3.10 3.12.0 MIT pytest-xdist pytest xdist plugin for distributed testing and loop-on-failing modes >=2.4 2.5.0 MIT python-dateutil Extensions to the standard Python datetime module >=2.8.1 2.8.2 Dual License pyyaml YAML parser and emitter for Python >=3.10 6.0 MIT pyyaml-env-tag A custom YAML tag for referencing environment variables in YAML files. >=0.1 0.1 MIT License requests Python HTTP for Humans. 2.28.1 Apache 2.0 ruamel.yaml ruamel.yaml is a YAML parser/emitter that supports roundtrip preservation of comments, seq/map flow style, and map key order >=0.17.21 0.17.21 MIT license ruamel.yaml.clib C version of reader, parser and emitter for ruamel.yaml derived from libyaml >=0.2.6; platform_python_implementation == \"CPython\" and python_version < \"3.11\" 0.2.6 MIT safety Checks installed dependencies for known vulnerabilities and licenses. >=2 2.1.1 MIT license semver Python helper for Semantic Versioning (http://semver.org/) ~=2.13 2.13.0 BSD setuptools Easily download, build, install, upgrade, and uninstall Python packages >=19.3 65.3.0 MIT License six Python 2 and 3 compatibility utilities >=1.5 1.16.0 MIT smmap A pure Python implementation of a sliding window memory map manager <6,>=3.0.1 5.0.0 BSD snowballstemmer This package provides 29 stemmers for 28 languages generated from Snowball algorithms. 2.2.0 BSD-3-Clause stevedore Manage dynamic plugins for Python applications >=1.20.0 4.0.0 Apache Software License toml Python Library for Tom's Obvious, Minimal Language >=0.10 0.10.2 MIT tomli A lil' TOML parser >=1.1.0; python_full_version < \"3.11.0a7\" 2.0.1 MIT License types-markdown Typing stubs for Markdown >=3.3 3.4.1 Apache-2.0 license types-toml Typing stubs for toml >=0.10 0.10.8 Apache-2.0 license typing-extensions Backported and Experimental Type Hints for Python 3.7+ >=3.10 4.3.0 Python Software Foundation License urllib3 HTTP library with thread-safe connection pooling, file post, and more. <1.27,>=1.21.1 1.26.12 MIT watchdog Filesystem events monitoring >=2.0 2.1.9 Apache License 2.0 wps-light The strictest and most opinionated python linter ever (lighter fork). >=0.15 0.16.1 MIT zipp Backport of pathlib-compatible object wrapper for zip files >=0.5 3.8.1 MIT License","title":"Credits"},{"location":"license/","text":"ISC License Copyright (c) 2021, LOGiCS Team Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies. THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.","title":"License"},{"location":"reference/SUMMARY/","text":"sym_cps classifier cli control database examples designs library topology grammar hci optimizers concrete_opt params_opt topo_opt representation design concrete elements component connection design_parameters parameter topology library elements c_connector c_parameter c_property c_type library_component tools analyze connectors export design_swri ids parsers learn_from_designs parse parsing_designs parsing_library temp_objects shared paths tools io persistance strings","title":"SUMMARY"},{"location":"reference/sym_cps/","text":"sym_cps package. Develop AI-based approaches to enable correct-by-construction design of Cyber Physical Systems","title":"sym_cps"},{"location":"reference/sym_cps/cli/","text":"Module that contains the command line application. get_parser () \u00b6 Return the CLI argument parser. Returns: Type Description argparse . ArgumentParser An argparse parser. Source code in sym_cps/cli.py 10 11 12 13 14 15 16 17 def get_parser () -> argparse . ArgumentParser : \"\"\" Return the CLI argument parser. Returns: An argparse parser. \"\"\" return argparse . ArgumentParser ( prog = \"sym-cps\" )","title":"cli"},{"location":"reference/sym_cps/cli/#sym_cps.cli.get_parser","text":"Return the CLI argument parser. Returns: Type Description argparse . ArgumentParser An argparse parser. Source code in sym_cps/cli.py 10 11 12 13 14 15 16 17 def get_parser () -> argparse . ArgumentParser : \"\"\" Return the CLI argument parser. Returns: An argparse parser. \"\"\" return argparse . ArgumentParser ( prog = \"sym-cps\" )","title":"get_parser()"},{"location":"reference/sym_cps/classifier/","text":"","title":"classifier"},{"location":"reference/sym_cps/control/","text":"","title":"control"},{"location":"reference/sym_cps/database/","text":"","title":"database"},{"location":"reference/sym_cps/examples/","text":"","title":"examples"},{"location":"reference/sym_cps/examples/designs/","text":"export_design_json ( design_name = 'Trowel' , designs_dat_file = 'designs.dat' ) \u00b6 Produce the json file representing the design Source code in sym_cps/examples/designs.py 12 13 14 15 16 17 18 19 20 21 22 23 def export_design_json ( design_name : str = \"Trowel\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Produce the json file representing the design\"\"\" designs : dict [ str , tuple [ DConcrete , DTopology ]] = load ( designs_dat_file ) # type: ignore d_concrete = designs [ design_name ][ 0 ] save_to_file ( str ( json . dumps ( d_concrete . to_design_swri )), file_name = f \"design_swri.json\" , absolute_folder_path = designs_folder / d_concrete . name , ) print ( f \" { design_name } exported to json\" ) load_design_json ( design_name = 'Trowel' , library_dat_file = 'library.dat' ) \u00b6 Load a design from json format Source code in sym_cps/examples/designs.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def load_design_json ( design_name : str = \"Trowel\" , library_dat_file : str = \"library.dat\" ): \"\"\"Load a design from json format\"\"\" \"\"\"BUG: FIXME: Does not work with new designs, e.g. NewAxe\"\"\" c_library : Library = load ( library_dat_file ) # type: ignore design_swri_path = designs_folder / design_name / \"design_swri.json\" d_concrete : DConcrete = parse_design_from_design_swri ( path = design_swri_path , library = c_library ) d_topology : DTopology = DTopology . from_concrete ( d_concrete ) print ( d_concrete ) print ( d_topology ) print ( f \" { design_name } imported from json\" )","title":"designs"},{"location":"reference/sym_cps/examples/designs/#sym_cps.examples.designs.export_design_json","text":"Produce the json file representing the design Source code in sym_cps/examples/designs.py 12 13 14 15 16 17 18 19 20 21 22 23 def export_design_json ( design_name : str = \"Trowel\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Produce the json file representing the design\"\"\" designs : dict [ str , tuple [ DConcrete , DTopology ]] = load ( designs_dat_file ) # type: ignore d_concrete = designs [ design_name ][ 0 ] save_to_file ( str ( json . dumps ( d_concrete . to_design_swri )), file_name = f \"design_swri.json\" , absolute_folder_path = designs_folder / d_concrete . name , ) print ( f \" { design_name } exported to json\" )","title":"export_design_json()"},{"location":"reference/sym_cps/examples/designs/#sym_cps.examples.designs.load_design_json","text":"Load a design from json format Source code in sym_cps/examples/designs.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def load_design_json ( design_name : str = \"Trowel\" , library_dat_file : str = \"library.dat\" ): \"\"\"Load a design from json format\"\"\" \"\"\"BUG: FIXME: Does not work with new designs, e.g. NewAxe\"\"\" c_library : Library = load ( library_dat_file ) # type: ignore design_swri_path = designs_folder / design_name / \"design_swri.json\" d_concrete : DConcrete = parse_design_from_design_swri ( path = design_swri_path , library = c_library ) d_topology : DTopology = DTopology . from_concrete ( d_concrete ) print ( d_concrete ) print ( d_topology ) print ( f \" { design_name } imported from json\" )","title":"load_design_json()"},{"location":"reference/sym_cps/examples/library/","text":"export_library ( library_txt_file = 'library.txt' , library_dat_file = 'library.dat' , designs_dat_file = 'designs.dat' ) \u00b6 Export library and seed designs to text files Source code in sym_cps/examples/library.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def export_library ( library_txt_file : str = \"library.txt\" , library_dat_file : str = \"library.dat\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Export library and seed designs to text files\"\"\" c_library : Library = load ( library_dat_file ) # type: ignore save_to_file ( str ( c_library ), file_name = library_txt_file , absolute_folder_path = library_folder ) \"\"\"In the following we can see some of the 'temporary objects' that have been build while building the components and designs libraries. We will save them to a text file in the output folder\"\"\" # Maps component type to all the LibraryComponent objects belonging to the type save_to_file ( repr_dictionary ( c_library . components_in_type ), \"all_components_in_type.txt\" , folder_name = \"library\" ) # Maps each component type to a set of components type which it can be connected to\"\"\" connectable_components_types : dict [ CType , set [ CType ]] = {} for ctype in c_library . component_types . values (): connectable_components_types [ ctype ] = set ( ctype . compatible_with . values ()) save_to_file ( repr_dictionary ( connectable_components_types ), \"connectable_components_types.txt\" , folder_name = \"library\" ) # Maps connector_id to its LibraryConnector object\"\"\" save_to_file ( repr_dictionary ( c_library . connectors ), \"all_connectors.txt\" , folder_name = \"library\" ) # Maps connector to a set of 'compatible' connectors it can be connected to\"\"\" connectable_connectors : dict [ CConnector , set [ CConnector ]] = {} for connector in c_library . connectors . values (): connectable_connectors [ connector ] = set ( connector . compatible_with . values ()) save_to_file ( repr_dictionary ( connectable_connectors ), \"connectable_connectors.txt\" , folder_name = \"library\" ) # all_parameters_upper_bounds: dict[str, float] = {} # Maps parameter_id to its upper bounds\"\"\" save_to_file ( repr_dictionary ( all_parameters_upper_bounds ), \"all_parameters_upper_bounds.txt\" , folder_name = \"library\" ) # all_parameters_lower_bounds: dict[str, float] = {} # Maps parameter_id to its lower bounds\"\"\" save_to_file ( repr_dictionary ( all_parameters_lower_bounds ), \"all_parameters_lower_bounds.txt\" , folder_name = \"library\" ) # all_parameters: dict[str, CParameterType] = {} # Maps parameter_id to CParameterType object\"\"\" save_to_file ( repr_dictionary ( c_library . parameters ), \"all_parameters.txt\" , folder_name = \"library\" ) # Maps parameter_id to a set of component types it belongs to\"\"\" parameter_to_components_types : dict [ str , set [ str ]] = {} for para_id , parameter in c_library . parameters . items (): if para_id not in parameter_to_components_types . keys (): parameter_to_components_types [ para_id ] = set () parameter_to_components_types [ para_id ] . add ( parameter . belongs_to ) save_to_file ( repr_dictionary ( parameter_to_components_types ), \"parameter_to_components_types.txt\" , folder_name = \"library\" ) designs : dict [ str , tuple [ DConcrete , DTopology ]] = load ( designs_dat_file ) # type: ignore for d_concrete , d_topology in designs . values (): save_to_file ( str ( d_concrete ), file_name = f \"DConcrete\" , absolute_folder_path = designs_folder / d_concrete . name , ) save_to_file ( str ( d_topology ), file_name = f \"DTopology\" , absolute_folder_path = designs_folder / d_concrete . name , ) parse_library ( library_dat_file = 'library.dat' , designs_dat_file = 'designs.dat' ) \u00b6 Loads library of components and seed designs and store them Source code in sym_cps/examples/library.py 14 15 16 17 18 19 def parse_library ( library_dat_file : str = \"library.dat\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Loads library of components and seed designs and store them\"\"\" c_library , designs = parse_library_and_seed_designs () dump ( c_library , library_dat_file ) dump ( designs , designs_dat_file )","title":"library"},{"location":"reference/sym_cps/examples/library/#sym_cps.examples.library.export_library","text":"Export library and seed designs to text files Source code in sym_cps/examples/library.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def export_library ( library_txt_file : str = \"library.txt\" , library_dat_file : str = \"library.dat\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Export library and seed designs to text files\"\"\" c_library : Library = load ( library_dat_file ) # type: ignore save_to_file ( str ( c_library ), file_name = library_txt_file , absolute_folder_path = library_folder ) \"\"\"In the following we can see some of the 'temporary objects' that have been build while building the components and designs libraries. We will save them to a text file in the output folder\"\"\" # Maps component type to all the LibraryComponent objects belonging to the type save_to_file ( repr_dictionary ( c_library . components_in_type ), \"all_components_in_type.txt\" , folder_name = \"library\" ) # Maps each component type to a set of components type which it can be connected to\"\"\" connectable_components_types : dict [ CType , set [ CType ]] = {} for ctype in c_library . component_types . values (): connectable_components_types [ ctype ] = set ( ctype . compatible_with . values ()) save_to_file ( repr_dictionary ( connectable_components_types ), \"connectable_components_types.txt\" , folder_name = \"library\" ) # Maps connector_id to its LibraryConnector object\"\"\" save_to_file ( repr_dictionary ( c_library . connectors ), \"all_connectors.txt\" , folder_name = \"library\" ) # Maps connector to a set of 'compatible' connectors it can be connected to\"\"\" connectable_connectors : dict [ CConnector , set [ CConnector ]] = {} for connector in c_library . connectors . values (): connectable_connectors [ connector ] = set ( connector . compatible_with . values ()) save_to_file ( repr_dictionary ( connectable_connectors ), \"connectable_connectors.txt\" , folder_name = \"library\" ) # all_parameters_upper_bounds: dict[str, float] = {} # Maps parameter_id to its upper bounds\"\"\" save_to_file ( repr_dictionary ( all_parameters_upper_bounds ), \"all_parameters_upper_bounds.txt\" , folder_name = \"library\" ) # all_parameters_lower_bounds: dict[str, float] = {} # Maps parameter_id to its lower bounds\"\"\" save_to_file ( repr_dictionary ( all_parameters_lower_bounds ), \"all_parameters_lower_bounds.txt\" , folder_name = \"library\" ) # all_parameters: dict[str, CParameterType] = {} # Maps parameter_id to CParameterType object\"\"\" save_to_file ( repr_dictionary ( c_library . parameters ), \"all_parameters.txt\" , folder_name = \"library\" ) # Maps parameter_id to a set of component types it belongs to\"\"\" parameter_to_components_types : dict [ str , set [ str ]] = {} for para_id , parameter in c_library . parameters . items (): if para_id not in parameter_to_components_types . keys (): parameter_to_components_types [ para_id ] = set () parameter_to_components_types [ para_id ] . add ( parameter . belongs_to ) save_to_file ( repr_dictionary ( parameter_to_components_types ), \"parameter_to_components_types.txt\" , folder_name = \"library\" ) designs : dict [ str , tuple [ DConcrete , DTopology ]] = load ( designs_dat_file ) # type: ignore for d_concrete , d_topology in designs . values (): save_to_file ( str ( d_concrete ), file_name = f \"DConcrete\" , absolute_folder_path = designs_folder / d_concrete . name , ) save_to_file ( str ( d_topology ), file_name = f \"DTopology\" , absolute_folder_path = designs_folder / d_concrete . name , )","title":"export_library()"},{"location":"reference/sym_cps/examples/library/#sym_cps.examples.library.parse_library","text":"Loads library of components and seed designs and store them Source code in sym_cps/examples/library.py 14 15 16 17 18 19 def parse_library ( library_dat_file : str = \"library.dat\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Loads library of components and seed designs and store them\"\"\" c_library , designs = parse_library_and_seed_designs () dump ( c_library , library_dat_file ) dump ( designs , designs_dat_file )","title":"parse_library()"},{"location":"reference/sym_cps/examples/topology/","text":"random_topology ( design_name = 'Trowel' , designs_dat_file = 'designs.dat' ) \u00b6 Generate Topology DTopology, random strategy Source code in sym_cps/examples/topology.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def random_topology ( design_name : str = \"Trowel\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Generate Topology DTopology, random strategy\"\"\" d_topology : DTopology = topo_opt . generate_topology ( name = \"RandomDesign\" , strategy = TopologyStrategy . random_strategy ) print ( \"****D_TOPOLOGY****\" ) print ( d_topology ) d_topology . export ( ExportType . TXT ) d_topology . export ( ExportType . DOT ) \"\"\"Refine DTopology to DConcrete, random strategy\"\"\" d_concrete : DConcrete = concr_opt . concretize_topology ( d_topology = d_topology , strategy = ConcreteStrategy . random_strategy ) print ( \" \\n ****D_CONCRETE****\" ) print ( d_concrete ) d_concrete . export ( ExportType . TXT ) d_concrete . export ( ExportType . DOT ) d_concrete . export ( ExportType . JSON ) d_concrete . export ( ExportType . PDF )","title":"topology"},{"location":"reference/sym_cps/examples/topology/#sym_cps.examples.topology.random_topology","text":"Generate Topology DTopology, random strategy Source code in sym_cps/examples/topology.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def random_topology ( design_name : str = \"Trowel\" , designs_dat_file : str = \"designs.dat\" ): \"\"\"Generate Topology DTopology, random strategy\"\"\" d_topology : DTopology = topo_opt . generate_topology ( name = \"RandomDesign\" , strategy = TopologyStrategy . random_strategy ) print ( \"****D_TOPOLOGY****\" ) print ( d_topology ) d_topology . export ( ExportType . TXT ) d_topology . export ( ExportType . DOT ) \"\"\"Refine DTopology to DConcrete, random strategy\"\"\" d_concrete : DConcrete = concr_opt . concretize_topology ( d_topology = d_topology , strategy = ConcreteStrategy . random_strategy ) print ( \" \\n ****D_CONCRETE****\" ) print ( d_concrete ) d_concrete . export ( ExportType . TXT ) d_concrete . export ( ExportType . DOT ) d_concrete . export ( ExportType . JSON ) d_concrete . export ( ExportType . PDF )","title":"random_topology()"},{"location":"reference/sym_cps/grammar/","text":"","title":"grammar"},{"location":"reference/sym_cps/hci/","text":"","title":"hci"},{"location":"reference/sym_cps/optimizers/","text":"","title":"optimizers"},{"location":"reference/sym_cps/optimizers/concrete_opt/","text":"Test ConcreteStrategy \u00b6 Bases: Enum Test Class Source code in sym_cps/optimizers/concrete_opt/__init__.py 16 17 18 19 20 class ConcreteStrategy ( Enum ): \"\"\" Test Class \"\"\" random_strategy = auto ()","title":"concrete_opt"},{"location":"reference/sym_cps/optimizers/concrete_opt/#sym_cps.optimizers.concrete_opt.ConcreteStrategy","text":"Bases: Enum Test Class Source code in sym_cps/optimizers/concrete_opt/__init__.py 16 17 18 19 20 class ConcreteStrategy ( Enum ): \"\"\" Test Class \"\"\" random_strategy = auto ()","title":"ConcreteStrategy"},{"location":"reference/sym_cps/optimizers/params_opt/","text":"","title":"params_opt"},{"location":"reference/sym_cps/optimizers/topo_opt/","text":"","title":"topo_opt"},{"location":"reference/sym_cps/representation/","text":"","title":"representation"},{"location":"reference/sym_cps/representation/design/","text":"","title":"design"},{"location":"reference/sym_cps/representation/design/concrete/","text":"Test Documentation DConcrete dataclass \u00b6 A class representing a Concrete Design ... Attributes \u00b6 str name of the design dict[str, DesignParameter] design parameters Source code in sym_cps/representation/design/concrete/__init__.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 @dataclass class DConcrete : \"\"\" A class representing a Concrete Design ... Attributes ---------- name : str name of the design design_parameters : dict[str, DesignParameter] design parameters \"\"\" name : str design_parameters : dict [ str , DesignParameter ] = field ( default_factory = dict ) def __post_init__ ( self ): self . _graph = Graph () @property def graph ( self ) -> Graph : return self . _graph @property def nodes ( self ) -> list [ igraph . Vertex ]: return list ( self . graph . vs ) @property def edges ( self ) -> list [ igraph . Edge ]: return list ( self . graph . es ) def get_vertex_by_id ( self , vid : int ) -> igraph . Vertex : return self . graph . vs [ vid ] @property def n_nodes ( self ) -> int : return len ( self . graph . vs ) @property def n_edges ( self ) -> int : return len ( self . graph . es ) def add_node ( self , component : Component ) -> igraph . Vertex : return self . graph . add_vertex ( instance = component . id , library_component = component . library_component , c_type = component . c_type , component = component , ) def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError def add_edge ( self , node_id_a : int , node_id_b : int , connection : Connection ): self . graph . add_edge ( source = node_id_a , target = node_id_b , connection = connection ) def connect ( self , connection : Connection ): a = self . get_node_by_instance ( connection . component_a . id ) . index b = self . get_node_by_instance ( connection . component_b . id ) . index self . add_edge ( a , b , connection ) def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError def disconnect ( self , connection : Connection ): \"\"\"TODO. Might want to remove a Connection, retrieve the node_id from the Connection\"\"\" raise NotImplementedError @property def components ( self ) -> set [ Component | None ]: if self . n_nodes > 0 : return set ( self . graph . vs ()[ \"component\" ]) return set () @property def connections ( self ) -> set [ Connection | None ]: if self . n_nodes > 0 : if self . n_edges > 0 : return set ( self . graph . es ()[ \"connection\" ]) return set () def get_node_by_instance ( self , instance : str ) -> igraph . Vertex | None : if self . n_nodes > 0 : nodes = self . graph . vs . select ( instance = instance ) if len ( nodes ) == 1 : return nodes [ 0 ] return None def get_instance ( self , instance : str ) -> Component | None : if self . n_nodes > 0 : nodes = self . graph . vs . select ( instance = instance ) if len ( nodes ) == 1 : return nodes [ \"component\" ][ 0 ] return None def select ( self , library_component : LibraryComponent | None = None , component_type : CType | None = None , ) -> set [ Component ]: components = set () if library_component is not None : return set ( self . graph . vs . select ( library_component = library_component )[ \"component\" ] ) if component_type is not None : return set ( self . graph . vs . select ( component_type = component_type )[ \"component\" ]) return components @property def all_library_components_component_class ( self , ) -> dict [ CType , set [ LibraryComponent ]]: \"\"\"Returns all LibraryComponent for each Component class in the design\"\"\" comp_types_n : dict [ CType , set [ LibraryComponent ]] = {} for component in self . components : if component . c_type in comp_types_n . keys (): comp_types_n [ component . c_type ] . add ( component . library_component ) else : comp_types_n [ component . c_type ] = { component . library_component } return comp_types_n @property def all_components_by_library_components ( self , ) -> dict [ LibraryComponent , set [ Component ]]: \"\"\"Returns all Components for each LibraryComponent in the design\"\"\" comp_types_n : dict [ LibraryComponent , set [ Component ]] = {} for component in self . components : if component . library_component in comp_types_n . keys (): comp_types_n [ component . library_component ] . add ( component ) else : comp_types_n [ component . library_component ] = { component } return comp_types_n def validate ( self ): \"\"\"Validates the Parameters of the Design\"\"\" raise NotImplementedError def evaluate ( self ): \"\"\"Sends the Design for evaluation\"\"\" raise NotImplementedError def evaluation ( self , evaluation_results_json : str ): \"\"\"Parse and update the evaluation of the Design\"\"\" raise NotImplementedError def export_to_cad ( self ): \"\"\"Generates a CAD representation of the Design\"\"\" raise NotImplementedError @property def to_design_swri ( self ) -> dict [ str , str ]: \"\"\"Generate design_swri.json format file from a concrete design design: the concrete design exporting to design_swri.json file output_path: file path for the export file. \"\"\" design_swri_data = {} \"\"\" Storing the design name\"\"\" design_swri_data [ \"name\" ] = self . name \"\"\"Storing parameters\"\"\" data_parameters : list = [] for component in self . components : for parameter_id , parameter in component . parameters . items (): data_parameters . append ( { \"parameter_name\" : f \" { component . id } _ { parameter . c_parameter . name } \" , \"value\" : str ( int ( parameter . value )), \"component_properties\" : [ { \"component_name\" : component . id , \"component_property\" : parameter . c_parameter . name , } ], } ) design_swri_data [ \"parameters\" ] = data_parameters \"\"\"Storing components\"\"\" data_components : list [ dict [ str , str ]] = [] for component in self . components : data_components . append ( { \"component_instance\" : component . id , \"component_type\" : component . c_type . id , \"component_choice\" : component . model , } ) design_swri_data [ \"components\" ] = data_components \"\"\"Storing connections\"\"\" data_connections : list [ dict [ str , str ]] = [] for connection in self . connections : data_connections . append ( { \"from_ci\" : connection . component_a . id , \"from_conn\" : connection . connector_a . name , \"to_ci\" : connection . component_b . id , \"to_conn\" : connection . connector_b . name , } ) data_connections . append ( { \"from_ci\" : connection . component_b . id , \"from_conn\" : connection . connector_b . name , \"to_ci\" : connection . component_a . id , \"to_conn\" : connection . connector_a . name , } ) design_swri_data [ \"connections\" ] = data_connections return design_swri_data def export ( self , file_type : ExportType ): absolute_folder = designs_folder / self . name if file_type == ExportType . TXT : save_to_file ( str ( self ), file_name = f \"DTopology\" , absolute_folder_path = absolute_folder , ) elif file_type == ExportType . JSON : save_to_file ( str ( json . dumps ( self . to_design_swri )), file_name = f \"design_swri.json\" , absolute_folder_path = absolute_folder , ) elif file_type == ExportType . DOT : self . graph . write_dot ( f = str ( absolute_folder / \"concrete_graph.dot\" )) elif file_type == ExportType . PDF : if self . n_nodes > 0 : layout = self . graph . layout ( \"kk\" ) \"\"\"Adding labels to nodes\"\"\" self . graph . vs [ \"label\" ] = self . graph . vs [ \"c_type\" ] fig , ax = plt . subplots () plot ( self . graph , layout = layout , target = ax ) plt . savefig ( absolute_folder / \"concrete_graph.pdf\" ) else : raise Exception ( \"File type not supported\" ) print ( f \" { file_type } file saved in { absolute_folder } \" ) def draw ( self , name ): if self . n_nodes > 0 : layout = self . graph . layout ( \"kk\" ) fig , ax = plt . subplots () plot ( self . graph , layout = layout , target = ax ) file_name_path = output_folder / \"graphs\" / name plt . savefig ( f \" { file_name_path } .pdf\" ) def __eq__ ( self , other : object ): pass def __ne__ ( self , other : object ): if not isinstance ( other , DConcrete ): return NotImplementedError return not self . __eq__ ( other ) def __str__ ( self ): n_library_component_by_class = [] for k , v in self . all_library_components_component_class . items (): n_library_component_by_class . append ( f \" \\t { k } : { len ( v ) } \" ) n_library_component_by_class_str = \" \\n \" . join ( n_library_component_by_class ) components_list = [] for ( components_class , library_components , ) in self . all_library_components_component_class . items (): components_list . append ( tab ( f \"COMPONENT type: { components_class } \" )) for library_component in library_components : components_list . append ( tab ( tab ( f \"LIBRARY COMPONENT: { library_component . id } \" )) ) components = self . select ( library_component = library_component ) for component in components : components_list . append ( tab ( tab ( tab ( f \"COMPONENT: { component . id } \" )))) components_list . append ( tab ( tab ( tab ( component )))) components_list . append ( \" \\n\\t +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\" ) components_str = \" \\n \" . join ( components_list ) s1 = ( f \"name: { self . name } \\n \" f \"#_components: { len ( self . components ) } \\n \" f \"#_connections: { len ( self . connections ) } \\n \" f \"#_component_classes: \\n { n_library_component_by_class_str } \\n \" f \"components: \\n { components_str } \\n \" ) return s1 all_components_by_library_components () property \u00b6 Returns all Components for each LibraryComponent in the design Source code in sym_cps/representation/design/concrete/__init__.py 148 149 150 151 152 153 154 155 156 157 158 159 @property def all_components_by_library_components ( self , ) -> dict [ LibraryComponent , set [ Component ]]: \"\"\"Returns all Components for each LibraryComponent in the design\"\"\" comp_types_n : dict [ LibraryComponent , set [ Component ]] = {} for component in self . components : if component . library_component in comp_types_n . keys (): comp_types_n [ component . library_component ] . add ( component ) else : comp_types_n [ component . library_component ] = { component } return comp_types_n all_library_components_component_class () property \u00b6 Returns all LibraryComponent for each Component class in the design Source code in sym_cps/representation/design/concrete/__init__.py 135 136 137 138 139 140 141 142 143 144 145 146 @property def all_library_components_component_class ( self , ) -> dict [ CType , set [ LibraryComponent ]]: \"\"\"Returns all LibraryComponent for each Component class in the design\"\"\" comp_types_n : dict [ CType , set [ LibraryComponent ]] = {} for component in self . components : if component . c_type in comp_types_n . keys (): comp_types_n [ component . c_type ] . add ( component . library_component ) else : comp_types_n [ component . c_type ] = { component . library_component } return comp_types_n disconnect ( connection ) \u00b6 TODO. Might want to remove a Connection, retrieve the node_id from the Connection Source code in sym_cps/representation/design/concrete/__init__.py 90 91 92 def disconnect ( self , connection : Connection ): \"\"\"TODO. Might want to remove a Connection, retrieve the node_id from the Connection\"\"\" raise NotImplementedError evaluate () \u00b6 Sends the Design for evaluation Source code in sym_cps/representation/design/concrete/__init__.py 165 166 167 def evaluate ( self ): \"\"\"Sends the Design for evaluation\"\"\" raise NotImplementedError evaluation ( evaluation_results_json ) \u00b6 Parse and update the evaluation of the Design Source code in sym_cps/representation/design/concrete/__init__.py 169 170 171 def evaluation ( self , evaluation_results_json : str ): \"\"\"Parse and update the evaluation of the Design\"\"\" raise NotImplementedError export_to_cad () \u00b6 Generates a CAD representation of the Design Source code in sym_cps/representation/design/concrete/__init__.py 173 174 175 def export_to_cad ( self ): \"\"\"Generates a CAD representation of the Design\"\"\" raise NotImplementedError remove_edge () \u00b6 TODO. Tip: self.graph.delete_edges Source code in sym_cps/representation/design/concrete/__init__.py 86 87 88 def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError remove_node () \u00b6 TODO Source code in sym_cps/representation/design/concrete/__init__.py 74 75 76 def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError to_design_swri () property \u00b6 Generate design_swri.json format file from a concrete design design: the concrete design exporting to design_swri.json file output_path: file path for the export file. Source code in sym_cps/representation/design/concrete/__init__.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 @property def to_design_swri ( self ) -> dict [ str , str ]: \"\"\"Generate design_swri.json format file from a concrete design design: the concrete design exporting to design_swri.json file output_path: file path for the export file. \"\"\" design_swri_data = {} \"\"\" Storing the design name\"\"\" design_swri_data [ \"name\" ] = self . name \"\"\"Storing parameters\"\"\" data_parameters : list = [] for component in self . components : for parameter_id , parameter in component . parameters . items (): data_parameters . append ( { \"parameter_name\" : f \" { component . id } _ { parameter . c_parameter . name } \" , \"value\" : str ( int ( parameter . value )), \"component_properties\" : [ { \"component_name\" : component . id , \"component_property\" : parameter . c_parameter . name , } ], } ) design_swri_data [ \"parameters\" ] = data_parameters \"\"\"Storing components\"\"\" data_components : list [ dict [ str , str ]] = [] for component in self . components : data_components . append ( { \"component_instance\" : component . id , \"component_type\" : component . c_type . id , \"component_choice\" : component . model , } ) design_swri_data [ \"components\" ] = data_components \"\"\"Storing connections\"\"\" data_connections : list [ dict [ str , str ]] = [] for connection in self . connections : data_connections . append ( { \"from_ci\" : connection . component_a . id , \"from_conn\" : connection . connector_a . name , \"to_ci\" : connection . component_b . id , \"to_conn\" : connection . connector_b . name , } ) data_connections . append ( { \"from_ci\" : connection . component_b . id , \"from_conn\" : connection . connector_b . name , \"to_ci\" : connection . component_a . id , \"to_conn\" : connection . connector_a . name , } ) design_swri_data [ \"connections\" ] = data_connections return design_swri_data validate () \u00b6 Validates the Parameters of the Design Source code in sym_cps/representation/design/concrete/__init__.py 161 162 163 def validate ( self ): \"\"\"Validates the Parameters of the Design\"\"\" raise NotImplementedError","title":"concrete"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete","text":"A class representing a Concrete Design ...","title":"DConcrete"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete--attributes","text":"str name of the design dict[str, DesignParameter] design parameters Source code in sym_cps/representation/design/concrete/__init__.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 @dataclass class DConcrete : \"\"\" A class representing a Concrete Design ... Attributes ---------- name : str name of the design design_parameters : dict[str, DesignParameter] design parameters \"\"\" name : str design_parameters : dict [ str , DesignParameter ] = field ( default_factory = dict ) def __post_init__ ( self ): self . _graph = Graph () @property def graph ( self ) -> Graph : return self . _graph @property def nodes ( self ) -> list [ igraph . Vertex ]: return list ( self . graph . vs ) @property def edges ( self ) -> list [ igraph . Edge ]: return list ( self . graph . es ) def get_vertex_by_id ( self , vid : int ) -> igraph . Vertex : return self . graph . vs [ vid ] @property def n_nodes ( self ) -> int : return len ( self . graph . vs ) @property def n_edges ( self ) -> int : return len ( self . graph . es ) def add_node ( self , component : Component ) -> igraph . Vertex : return self . graph . add_vertex ( instance = component . id , library_component = component . library_component , c_type = component . c_type , component = component , ) def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError def add_edge ( self , node_id_a : int , node_id_b : int , connection : Connection ): self . graph . add_edge ( source = node_id_a , target = node_id_b , connection = connection ) def connect ( self , connection : Connection ): a = self . get_node_by_instance ( connection . component_a . id ) . index b = self . get_node_by_instance ( connection . component_b . id ) . index self . add_edge ( a , b , connection ) def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError def disconnect ( self , connection : Connection ): \"\"\"TODO. Might want to remove a Connection, retrieve the node_id from the Connection\"\"\" raise NotImplementedError @property def components ( self ) -> set [ Component | None ]: if self . n_nodes > 0 : return set ( self . graph . vs ()[ \"component\" ]) return set () @property def connections ( self ) -> set [ Connection | None ]: if self . n_nodes > 0 : if self . n_edges > 0 : return set ( self . graph . es ()[ \"connection\" ]) return set () def get_node_by_instance ( self , instance : str ) -> igraph . Vertex | None : if self . n_nodes > 0 : nodes = self . graph . vs . select ( instance = instance ) if len ( nodes ) == 1 : return nodes [ 0 ] return None def get_instance ( self , instance : str ) -> Component | None : if self . n_nodes > 0 : nodes = self . graph . vs . select ( instance = instance ) if len ( nodes ) == 1 : return nodes [ \"component\" ][ 0 ] return None def select ( self , library_component : LibraryComponent | None = None , component_type : CType | None = None , ) -> set [ Component ]: components = set () if library_component is not None : return set ( self . graph . vs . select ( library_component = library_component )[ \"component\" ] ) if component_type is not None : return set ( self . graph . vs . select ( component_type = component_type )[ \"component\" ]) return components @property def all_library_components_component_class ( self , ) -> dict [ CType , set [ LibraryComponent ]]: \"\"\"Returns all LibraryComponent for each Component class in the design\"\"\" comp_types_n : dict [ CType , set [ LibraryComponent ]] = {} for component in self . components : if component . c_type in comp_types_n . keys (): comp_types_n [ component . c_type ] . add ( component . library_component ) else : comp_types_n [ component . c_type ] = { component . library_component } return comp_types_n @property def all_components_by_library_components ( self , ) -> dict [ LibraryComponent , set [ Component ]]: \"\"\"Returns all Components for each LibraryComponent in the design\"\"\" comp_types_n : dict [ LibraryComponent , set [ Component ]] = {} for component in self . components : if component . library_component in comp_types_n . keys (): comp_types_n [ component . library_component ] . add ( component ) else : comp_types_n [ component . library_component ] = { component } return comp_types_n def validate ( self ): \"\"\"Validates the Parameters of the Design\"\"\" raise NotImplementedError def evaluate ( self ): \"\"\"Sends the Design for evaluation\"\"\" raise NotImplementedError def evaluation ( self , evaluation_results_json : str ): \"\"\"Parse and update the evaluation of the Design\"\"\" raise NotImplementedError def export_to_cad ( self ): \"\"\"Generates a CAD representation of the Design\"\"\" raise NotImplementedError @property def to_design_swri ( self ) -> dict [ str , str ]: \"\"\"Generate design_swri.json format file from a concrete design design: the concrete design exporting to design_swri.json file output_path: file path for the export file. \"\"\" design_swri_data = {} \"\"\" Storing the design name\"\"\" design_swri_data [ \"name\" ] = self . name \"\"\"Storing parameters\"\"\" data_parameters : list = [] for component in self . components : for parameter_id , parameter in component . parameters . items (): data_parameters . append ( { \"parameter_name\" : f \" { component . id } _ { parameter . c_parameter . name } \" , \"value\" : str ( int ( parameter . value )), \"component_properties\" : [ { \"component_name\" : component . id , \"component_property\" : parameter . c_parameter . name , } ], } ) design_swri_data [ \"parameters\" ] = data_parameters \"\"\"Storing components\"\"\" data_components : list [ dict [ str , str ]] = [] for component in self . components : data_components . append ( { \"component_instance\" : component . id , \"component_type\" : component . c_type . id , \"component_choice\" : component . model , } ) design_swri_data [ \"components\" ] = data_components \"\"\"Storing connections\"\"\" data_connections : list [ dict [ str , str ]] = [] for connection in self . connections : data_connections . append ( { \"from_ci\" : connection . component_a . id , \"from_conn\" : connection . connector_a . name , \"to_ci\" : connection . component_b . id , \"to_conn\" : connection . connector_b . name , } ) data_connections . append ( { \"from_ci\" : connection . component_b . id , \"from_conn\" : connection . connector_b . name , \"to_ci\" : connection . component_a . id , \"to_conn\" : connection . connector_a . name , } ) design_swri_data [ \"connections\" ] = data_connections return design_swri_data def export ( self , file_type : ExportType ): absolute_folder = designs_folder / self . name if file_type == ExportType . TXT : save_to_file ( str ( self ), file_name = f \"DTopology\" , absolute_folder_path = absolute_folder , ) elif file_type == ExportType . JSON : save_to_file ( str ( json . dumps ( self . to_design_swri )), file_name = f \"design_swri.json\" , absolute_folder_path = absolute_folder , ) elif file_type == ExportType . DOT : self . graph . write_dot ( f = str ( absolute_folder / \"concrete_graph.dot\" )) elif file_type == ExportType . PDF : if self . n_nodes > 0 : layout = self . graph . layout ( \"kk\" ) \"\"\"Adding labels to nodes\"\"\" self . graph . vs [ \"label\" ] = self . graph . vs [ \"c_type\" ] fig , ax = plt . subplots () plot ( self . graph , layout = layout , target = ax ) plt . savefig ( absolute_folder / \"concrete_graph.pdf\" ) else : raise Exception ( \"File type not supported\" ) print ( f \" { file_type } file saved in { absolute_folder } \" ) def draw ( self , name ): if self . n_nodes > 0 : layout = self . graph . layout ( \"kk\" ) fig , ax = plt . subplots () plot ( self . graph , layout = layout , target = ax ) file_name_path = output_folder / \"graphs\" / name plt . savefig ( f \" { file_name_path } .pdf\" ) def __eq__ ( self , other : object ): pass def __ne__ ( self , other : object ): if not isinstance ( other , DConcrete ): return NotImplementedError return not self . __eq__ ( other ) def __str__ ( self ): n_library_component_by_class = [] for k , v in self . all_library_components_component_class . items (): n_library_component_by_class . append ( f \" \\t { k } : { len ( v ) } \" ) n_library_component_by_class_str = \" \\n \" . join ( n_library_component_by_class ) components_list = [] for ( components_class , library_components , ) in self . all_library_components_component_class . items (): components_list . append ( tab ( f \"COMPONENT type: { components_class } \" )) for library_component in library_components : components_list . append ( tab ( tab ( f \"LIBRARY COMPONENT: { library_component . id } \" )) ) components = self . select ( library_component = library_component ) for component in components : components_list . append ( tab ( tab ( tab ( f \"COMPONENT: { component . id } \" )))) components_list . append ( tab ( tab ( tab ( component )))) components_list . append ( \" \\n\\t +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\" ) components_str = \" \\n \" . join ( components_list ) s1 = ( f \"name: { self . name } \\n \" f \"#_components: { len ( self . components ) } \\n \" f \"#_connections: { len ( self . connections ) } \\n \" f \"#_component_classes: \\n { n_library_component_by_class_str } \\n \" f \"components: \\n { components_str } \\n \" ) return s1","title":"Attributes"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.all_components_by_library_components","text":"Returns all Components for each LibraryComponent in the design Source code in sym_cps/representation/design/concrete/__init__.py 148 149 150 151 152 153 154 155 156 157 158 159 @property def all_components_by_library_components ( self , ) -> dict [ LibraryComponent , set [ Component ]]: \"\"\"Returns all Components for each LibraryComponent in the design\"\"\" comp_types_n : dict [ LibraryComponent , set [ Component ]] = {} for component in self . components : if component . library_component in comp_types_n . keys (): comp_types_n [ component . library_component ] . add ( component ) else : comp_types_n [ component . library_component ] = { component } return comp_types_n","title":"all_components_by_library_components()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.all_library_components_component_class","text":"Returns all LibraryComponent for each Component class in the design Source code in sym_cps/representation/design/concrete/__init__.py 135 136 137 138 139 140 141 142 143 144 145 146 @property def all_library_components_component_class ( self , ) -> dict [ CType , set [ LibraryComponent ]]: \"\"\"Returns all LibraryComponent for each Component class in the design\"\"\" comp_types_n : dict [ CType , set [ LibraryComponent ]] = {} for component in self . components : if component . c_type in comp_types_n . keys (): comp_types_n [ component . c_type ] . add ( component . library_component ) else : comp_types_n [ component . c_type ] = { component . library_component } return comp_types_n","title":"all_library_components_component_class()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.disconnect","text":"TODO. Might want to remove a Connection, retrieve the node_id from the Connection Source code in sym_cps/representation/design/concrete/__init__.py 90 91 92 def disconnect ( self , connection : Connection ): \"\"\"TODO. Might want to remove a Connection, retrieve the node_id from the Connection\"\"\" raise NotImplementedError","title":"disconnect()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.evaluate","text":"Sends the Design for evaluation Source code in sym_cps/representation/design/concrete/__init__.py 165 166 167 def evaluate ( self ): \"\"\"Sends the Design for evaluation\"\"\" raise NotImplementedError","title":"evaluate()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.evaluation","text":"Parse and update the evaluation of the Design Source code in sym_cps/representation/design/concrete/__init__.py 169 170 171 def evaluation ( self , evaluation_results_json : str ): \"\"\"Parse and update the evaluation of the Design\"\"\" raise NotImplementedError","title":"evaluation()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.export_to_cad","text":"Generates a CAD representation of the Design Source code in sym_cps/representation/design/concrete/__init__.py 173 174 175 def export_to_cad ( self ): \"\"\"Generates a CAD representation of the Design\"\"\" raise NotImplementedError","title":"export_to_cad()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.remove_edge","text":"TODO. Tip: self.graph.delete_edges Source code in sym_cps/representation/design/concrete/__init__.py 86 87 88 def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError","title":"remove_edge()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.remove_node","text":"TODO Source code in sym_cps/representation/design/concrete/__init__.py 74 75 76 def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError","title":"remove_node()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.to_design_swri","text":"Generate design_swri.json format file from a concrete design design: the concrete design exporting to design_swri.json file output_path: file path for the export file. Source code in sym_cps/representation/design/concrete/__init__.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 @property def to_design_swri ( self ) -> dict [ str , str ]: \"\"\"Generate design_swri.json format file from a concrete design design: the concrete design exporting to design_swri.json file output_path: file path for the export file. \"\"\" design_swri_data = {} \"\"\" Storing the design name\"\"\" design_swri_data [ \"name\" ] = self . name \"\"\"Storing parameters\"\"\" data_parameters : list = [] for component in self . components : for parameter_id , parameter in component . parameters . items (): data_parameters . append ( { \"parameter_name\" : f \" { component . id } _ { parameter . c_parameter . name } \" , \"value\" : str ( int ( parameter . value )), \"component_properties\" : [ { \"component_name\" : component . id , \"component_property\" : parameter . c_parameter . name , } ], } ) design_swri_data [ \"parameters\" ] = data_parameters \"\"\"Storing components\"\"\" data_components : list [ dict [ str , str ]] = [] for component in self . components : data_components . append ( { \"component_instance\" : component . id , \"component_type\" : component . c_type . id , \"component_choice\" : component . model , } ) design_swri_data [ \"components\" ] = data_components \"\"\"Storing connections\"\"\" data_connections : list [ dict [ str , str ]] = [] for connection in self . connections : data_connections . append ( { \"from_ci\" : connection . component_a . id , \"from_conn\" : connection . connector_a . name , \"to_ci\" : connection . component_b . id , \"to_conn\" : connection . connector_b . name , } ) data_connections . append ( { \"from_ci\" : connection . component_b . id , \"from_conn\" : connection . connector_b . name , \"to_ci\" : connection . component_a . id , \"to_conn\" : connection . connector_a . name , } ) design_swri_data [ \"connections\" ] = data_connections return design_swri_data","title":"to_design_swri()"},{"location":"reference/sym_cps/representation/design/concrete/#sym_cps.representation.design.concrete.DConcrete.validate","text":"Validates the Parameters of the Design Source code in sym_cps/representation/design/concrete/__init__.py 161 162 163 def validate ( self ): \"\"\"Validates the Parameters of the Design\"\"\" raise NotImplementedError","title":"validate()"},{"location":"reference/sym_cps/representation/design/concrete/elements/","text":"","title":"elements"},{"location":"reference/sym_cps/representation/design/concrete/elements/component/","text":"Component dataclass \u00b6 Source code in sym_cps/representation/design/concrete/elements/component.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 @dataclass ( frozen = True ) class Component : id : str library_component : LibraryComponent parameters : dict [ str , Parameter ] = field ( default_factory = dict ) def __post_init__ ( self ): \"\"\"Fill up all the parameters with the assigned_value, or default_value\"\"\" for parameter_accepted in self . configurable_parameters : if parameter_accepted . id not in self . parameters . keys (): if \"assigned_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"assigned_val\" ]), c_parameter = parameter_accepted , component = self , ) elif \"default_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"default_val\" ]), c_parameter = parameter_accepted , component = self , ) else : raise Exception ( f \"Parameter { parameter_accepted . id } does not have assigned_val nor default_val\" ) self . parameters [ parameter_accepted . id ] = new_parameter for parameter in self . parameters . values (): parameter . component = self @property def model ( self ) -> str : return self . library_component . id @property def c_type ( self ) -> CType : return self . library_component . comp_type @property def properties ( self ) -> dict [ str , CProperty ]: return self . library_component . properties @property def configurable_parameters ( self ) -> set [ CParameter ]: \"\"\"Returns the set of all ParameterType that can be configured in the Component\"\"\" return set ( self . library_component . parameters . values ()) @property def params_props_values ( self ) -> dict [ str , float | str ]: \"\"\"Returns dictionary: with the values of each parameter and property of the component\"\"\" params_props_values : dict [ str , float | str ] = {} for param_id , parameter in self . parameters . items (): params_props_values [ param_id ] = parameter . value for property_id , property in self . properties . items (): params_props_values [ property_id ] = property . value return params_props_values def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) attr . update ( value ) object . __setattr__ ( self , name , attr ) def __eq__ ( self , other : object ): if not isinstance ( other , Component ): return NotImplemented if self . library_component != other . library_component : return False if self . params_props_values != self . params_props_values : return False return True def __ne__ ( self , other : object ): if not isinstance ( other , Component ): return NotImplemented return not self . __eq__ ( other ) def __hash__ ( self ): return abs ( hash ( self . id )) def __str__ ( self ): s1 = f \"name: { self . model } \\n \" f \"type: { self . c_type } \\n \" parameters_str = [] for k , v in self . parameters . items (): parameters_str . append ( f \" \\t { k } : { v } \" ) parameters = \" \\n \" . join ( parameters_str ) if len ( parameters_str ) != 0 : s2 = f \"parameters: \\n { parameters } \\n \" else : s2 = \"\" return s1 + s2 __post_init__ () \u00b6 Fill up all the parameters with the assigned_value, or default_value Source code in sym_cps/representation/design/concrete/elements/component.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def __post_init__ ( self ): \"\"\"Fill up all the parameters with the assigned_value, or default_value\"\"\" for parameter_accepted in self . configurable_parameters : if parameter_accepted . id not in self . parameters . keys (): if \"assigned_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"assigned_val\" ]), c_parameter = parameter_accepted , component = self , ) elif \"default_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"default_val\" ]), c_parameter = parameter_accepted , component = self , ) else : raise Exception ( f \"Parameter { parameter_accepted . id } does not have assigned_val nor default_val\" ) self . parameters [ parameter_accepted . id ] = new_parameter for parameter in self . parameters . values (): parameter . component = self configurable_parameters () property \u00b6 Returns the set of all ParameterType that can be configured in the Component Source code in sym_cps/representation/design/concrete/elements/component.py 56 57 58 59 @property def configurable_parameters ( self ) -> set [ CParameter ]: \"\"\"Returns the set of all ParameterType that can be configured in the Component\"\"\" return set ( self . library_component . parameters . values ()) params_props_values () property \u00b6 Returns dictionary: with the values of each parameter and property of the component Source code in sym_cps/representation/design/concrete/elements/component.py 61 62 63 64 65 66 67 68 69 70 71 @property def params_props_values ( self ) -> dict [ str , float | str ]: \"\"\"Returns dictionary: with the values of each parameter and property of the component\"\"\" params_props_values : dict [ str , float | str ] = {} for param_id , parameter in self . parameters . items (): params_props_values [ param_id ] = parameter . value for property_id , property in self . properties . items (): params_props_values [ property_id ] = property . value return params_props_values","title":"component"},{"location":"reference/sym_cps/representation/design/concrete/elements/component/#sym_cps.representation.design.concrete.elements.component.Component","text":"Source code in sym_cps/representation/design/concrete/elements/component.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 @dataclass ( frozen = True ) class Component : id : str library_component : LibraryComponent parameters : dict [ str , Parameter ] = field ( default_factory = dict ) def __post_init__ ( self ): \"\"\"Fill up all the parameters with the assigned_value, or default_value\"\"\" for parameter_accepted in self . configurable_parameters : if parameter_accepted . id not in self . parameters . keys (): if \"assigned_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"assigned_val\" ]), c_parameter = parameter_accepted , component = self , ) elif \"default_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"default_val\" ]), c_parameter = parameter_accepted , component = self , ) else : raise Exception ( f \"Parameter { parameter_accepted . id } does not have assigned_val nor default_val\" ) self . parameters [ parameter_accepted . id ] = new_parameter for parameter in self . parameters . values (): parameter . component = self @property def model ( self ) -> str : return self . library_component . id @property def c_type ( self ) -> CType : return self . library_component . comp_type @property def properties ( self ) -> dict [ str , CProperty ]: return self . library_component . properties @property def configurable_parameters ( self ) -> set [ CParameter ]: \"\"\"Returns the set of all ParameterType that can be configured in the Component\"\"\" return set ( self . library_component . parameters . values ()) @property def params_props_values ( self ) -> dict [ str , float | str ]: \"\"\"Returns dictionary: with the values of each parameter and property of the component\"\"\" params_props_values : dict [ str , float | str ] = {} for param_id , parameter in self . parameters . items (): params_props_values [ param_id ] = parameter . value for property_id , property in self . properties . items (): params_props_values [ property_id ] = property . value return params_props_values def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) attr . update ( value ) object . __setattr__ ( self , name , attr ) def __eq__ ( self , other : object ): if not isinstance ( other , Component ): return NotImplemented if self . library_component != other . library_component : return False if self . params_props_values != self . params_props_values : return False return True def __ne__ ( self , other : object ): if not isinstance ( other , Component ): return NotImplemented return not self . __eq__ ( other ) def __hash__ ( self ): return abs ( hash ( self . id )) def __str__ ( self ): s1 = f \"name: { self . model } \\n \" f \"type: { self . c_type } \\n \" parameters_str = [] for k , v in self . parameters . items (): parameters_str . append ( f \" \\t { k } : { v } \" ) parameters = \" \\n \" . join ( parameters_str ) if len ( parameters_str ) != 0 : s2 = f \"parameters: \\n { parameters } \\n \" else : s2 = \"\" return s1 + s2","title":"Component"},{"location":"reference/sym_cps/representation/design/concrete/elements/component/#sym_cps.representation.design.concrete.elements.component.Component.__post_init__","text":"Fill up all the parameters with the assigned_value, or default_value Source code in sym_cps/representation/design/concrete/elements/component.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def __post_init__ ( self ): \"\"\"Fill up all the parameters with the assigned_value, or default_value\"\"\" for parameter_accepted in self . configurable_parameters : if parameter_accepted . id not in self . parameters . keys (): if \"assigned_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"assigned_val\" ]), c_parameter = parameter_accepted , component = self , ) elif \"default_val\" in parameter_accepted . values . keys (): new_parameter = Parameter ( value = float ( parameter_accepted . values [ \"default_val\" ]), c_parameter = parameter_accepted , component = self , ) else : raise Exception ( f \"Parameter { parameter_accepted . id } does not have assigned_val nor default_val\" ) self . parameters [ parameter_accepted . id ] = new_parameter for parameter in self . parameters . values (): parameter . component = self","title":"__post_init__()"},{"location":"reference/sym_cps/representation/design/concrete/elements/component/#sym_cps.representation.design.concrete.elements.component.Component.configurable_parameters","text":"Returns the set of all ParameterType that can be configured in the Component Source code in sym_cps/representation/design/concrete/elements/component.py 56 57 58 59 @property def configurable_parameters ( self ) -> set [ CParameter ]: \"\"\"Returns the set of all ParameterType that can be configured in the Component\"\"\" return set ( self . library_component . parameters . values ())","title":"configurable_parameters()"},{"location":"reference/sym_cps/representation/design/concrete/elements/component/#sym_cps.representation.design.concrete.elements.component.Component.params_props_values","text":"Returns dictionary: with the values of each parameter and property of the component Source code in sym_cps/representation/design/concrete/elements/component.py 61 62 63 64 65 66 67 68 69 70 71 @property def params_props_values ( self ) -> dict [ str , float | str ]: \"\"\"Returns dictionary: with the values of each parameter and property of the component\"\"\" params_props_values : dict [ str , float | str ] = {} for param_id , parameter in self . parameters . items (): params_props_values [ param_id ] = parameter . value for property_id , property in self . properties . items (): params_props_values [ property_id ] = property . value return params_props_values","title":"params_props_values()"},{"location":"reference/sym_cps/representation/design/concrete/elements/connection/","text":"Connection dataclass \u00b6 Models the connection between two 'Component'. Each Connection is symmetric, i.e. Connection(A,B) = Connection(B,A) Source code in sym_cps/representation/design/concrete/elements/connection.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @dataclass ( frozen = True ) class Connection : \"\"\"Models the connection between two 'Component'. Each Connection is symmetric, i.e. Connection(A,B) = Connection(B,A)\"\"\" component_a : Component connector_a : CConnector component_b : Component connector_b : CConnector def __post_init__ ( self ): \"\"\"TODO: is connection legal?\"\"\" @property def components_and_connectors ( self ) -> set [ tuple [ Component , CConnector ]]: \"\"\"Returns a set of two tuples, where each tuple is formed by a Component and a CConnector\"\"\" connections = set () connections . add (( self . component_a , self . connector_a )) connections . add (( self . component_b , self . connector_b )) return connections @property def components ( self ) -> tuple [ Component , Component ]: \"\"\"Returns the two components connected\"\"\" return self . component_a , self . component_b @property def key ( self ) -> str : a1 = self . component_a . id a2 = self . connector_a . id b1 = self . component_b . id b2 = self . connector_b . id if ( a1 + a2 ) >= ( b1 + b2 ): return f \" { a1 } - { a2 } - { b1 } - { b2 } \" return f \" { b1 } - { b2 } - { a1 } - { a2 } \" def __eq__ ( self , other : object ): if not isinstance ( other , Connection ): return NotImplementedError return self . key == other . key def __ne__ ( self , other : object ): if not isinstance ( other , Connection ): return NotImplementedError return not self . __eq__ ( other ) def __hash__ ( self ): return abs ( hash ( self . key )) __post_init__ () \u00b6 Todo is connection legal? Source code in sym_cps/representation/design/concrete/elements/connection.py 21 22 def __post_init__ ( self ): \"\"\"TODO: is connection legal?\"\"\" components () property \u00b6 Returns the two components connected Source code in sym_cps/representation/design/concrete/elements/connection.py 33 34 35 36 37 @property def components ( self ) -> tuple [ Component , Component ]: \"\"\"Returns the two components connected\"\"\" return self . component_a , self . component_b components_and_connectors () property \u00b6 Returns a set of two tuples, where each tuple is formed by a Component and a CConnector Source code in sym_cps/representation/design/concrete/elements/connection.py 24 25 26 27 28 29 30 31 @property def components_and_connectors ( self ) -> set [ tuple [ Component , CConnector ]]: \"\"\"Returns a set of two tuples, where each tuple is formed by a Component and a CConnector\"\"\" connections = set () connections . add (( self . component_a , self . connector_a )) connections . add (( self . component_b , self . connector_b )) return connections","title":"connection"},{"location":"reference/sym_cps/representation/design/concrete/elements/connection/#sym_cps.representation.design.concrete.elements.connection.Connection","text":"Models the connection between two 'Component'. Each Connection is symmetric, i.e. Connection(A,B) = Connection(B,A) Source code in sym_cps/representation/design/concrete/elements/connection.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @dataclass ( frozen = True ) class Connection : \"\"\"Models the connection between two 'Component'. Each Connection is symmetric, i.e. Connection(A,B) = Connection(B,A)\"\"\" component_a : Component connector_a : CConnector component_b : Component connector_b : CConnector def __post_init__ ( self ): \"\"\"TODO: is connection legal?\"\"\" @property def components_and_connectors ( self ) -> set [ tuple [ Component , CConnector ]]: \"\"\"Returns a set of two tuples, where each tuple is formed by a Component and a CConnector\"\"\" connections = set () connections . add (( self . component_a , self . connector_a )) connections . add (( self . component_b , self . connector_b )) return connections @property def components ( self ) -> tuple [ Component , Component ]: \"\"\"Returns the two components connected\"\"\" return self . component_a , self . component_b @property def key ( self ) -> str : a1 = self . component_a . id a2 = self . connector_a . id b1 = self . component_b . id b2 = self . connector_b . id if ( a1 + a2 ) >= ( b1 + b2 ): return f \" { a1 } - { a2 } - { b1 } - { b2 } \" return f \" { b1 } - { b2 } - { a1 } - { a2 } \" def __eq__ ( self , other : object ): if not isinstance ( other , Connection ): return NotImplementedError return self . key == other . key def __ne__ ( self , other : object ): if not isinstance ( other , Connection ): return NotImplementedError return not self . __eq__ ( other ) def __hash__ ( self ): return abs ( hash ( self . key ))","title":"Connection"},{"location":"reference/sym_cps/representation/design/concrete/elements/connection/#sym_cps.representation.design.concrete.elements.connection.Connection.__post_init__","text":"Todo is connection legal? Source code in sym_cps/representation/design/concrete/elements/connection.py 21 22 def __post_init__ ( self ): \"\"\"TODO: is connection legal?\"\"\"","title":"__post_init__()"},{"location":"reference/sym_cps/representation/design/concrete/elements/connection/#sym_cps.representation.design.concrete.elements.connection.Connection.components","text":"Returns the two components connected Source code in sym_cps/representation/design/concrete/elements/connection.py 33 34 35 36 37 @property def components ( self ) -> tuple [ Component , Component ]: \"\"\"Returns the two components connected\"\"\" return self . component_a , self . component_b","title":"components()"},{"location":"reference/sym_cps/representation/design/concrete/elements/connection/#sym_cps.representation.design.concrete.elements.connection.Connection.components_and_connectors","text":"Returns a set of two tuples, where each tuple is formed by a Component and a CConnector Source code in sym_cps/representation/design/concrete/elements/connection.py 24 25 26 27 28 29 30 31 @property def components_and_connectors ( self ) -> set [ tuple [ Component , CConnector ]]: \"\"\"Returns a set of two tuples, where each tuple is formed by a Component and a CConnector\"\"\" connections = set () connections . add (( self . component_a , self . connector_a )) connections . add (( self . component_b , self . connector_b )) return connections","title":"components_and_connectors()"},{"location":"reference/sym_cps/representation/design/concrete/elements/design_parameters/","text":"","title":"design_parameters"},{"location":"reference/sym_cps/representation/design/concrete/elements/parameter/","text":"","title":"parameter"},{"location":"reference/sym_cps/representation/design/topology/","text":"DTopology dataclass \u00b6 Source code in sym_cps/representation/design/topology/__init__.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @dataclass class DTopology : name : str def __post_init__ ( self ): self . _graph = Graph () @property def graph ( self ) -> Graph : return self . _graph @classmethod def from_concrete ( cls , d_concrete : DConcrete ) -> DTopology : # Create all the vertexes with the same id in d_concrete: d_topology = cls ( name = d_concrete . name ) for i in range ( d_concrete . n_nodes ): vertex = d_concrete . get_vertex_by_id ( i ) component : Component = vertex [ \"component\" ] d_topology . add_node ( c_type = component . library_component . comp_type ) # print(f\"{vertex.index} - {new_vertex.index}\") for edge in d_concrete . edges : d_topology . add_edge ( edge . source , edge . target ) return d_topology @property def nodes ( self ) -> list [ igraph . Vertex ]: return list ( self . graph . vs ) def get_vertex_by_id ( self , vid : int ) -> igraph . Vertex : return self . graph . vs [ vid ] @property def edges ( self ) -> list [ igraph . Edge ]: return list ( self . graph . es ) @property def n_nodes ( self ) -> int : return len ( self . graph . vs ) def add_node ( self , c_type : CType ) -> igraph . Vertex : return self . graph . add_vertex ( c_type = c_type , label = c_type . id ) def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError def add_edge ( self , node_id_a : int , node_id_b : int ): self . graph . add_edge ( source = node_id_a , target = node_id_b ) def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError @property def components ( self ) -> set [ CType ]: if self . n_nodes > 0 : return set ( self . graph . vs ()[ \"c_type\" ]) return set () @property def edges ( self ) -> list [ igraph . Edge ]: return list ( self . graph . es ) def draw_random_node ( self ) -> igraph . Vertex | None : if self . n_nodes == 0 : return None return choice ( self . nodes ) def export ( self , file_type : ExportType ): absolute_folder = designs_folder / self . name if file_type == ExportType . TXT : save_to_file ( str ( self ), file_name = f \"DTopology\" , absolute_folder_path = absolute_folder , ) elif file_type == ExportType . JSON : raise Exception ( \"Can't create JSON from DTopology. It must be from DConcrete.\" ) elif file_type == ExportType . DOT : self . graph . write_dot ( f = str ( absolute_folder / \"topo_graph.dot\" )) else : raise Exception ( \"File type not supported\" ) print ( f \" { file_type } file saved in { absolute_folder } \" ) def __str__ ( self ): ret = str ( self . graph ) ret += \" \\n \" for node in self . nodes : ret += f \" { node . index } : { node [ 'c_type' ] } \\n \" return ret remove_edge () \u00b6 TODO. Tip: self.graph.delete_edges Source code in sym_cps/representation/design/topology/__init__.py 68 69 70 def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError remove_node () \u00b6 TODO Source code in sym_cps/representation/design/topology/__init__.py 61 62 63 def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError","title":"topology"},{"location":"reference/sym_cps/representation/design/topology/#sym_cps.representation.design.topology.DTopology","text":"Source code in sym_cps/representation/design/topology/__init__.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @dataclass class DTopology : name : str def __post_init__ ( self ): self . _graph = Graph () @property def graph ( self ) -> Graph : return self . _graph @classmethod def from_concrete ( cls , d_concrete : DConcrete ) -> DTopology : # Create all the vertexes with the same id in d_concrete: d_topology = cls ( name = d_concrete . name ) for i in range ( d_concrete . n_nodes ): vertex = d_concrete . get_vertex_by_id ( i ) component : Component = vertex [ \"component\" ] d_topology . add_node ( c_type = component . library_component . comp_type ) # print(f\"{vertex.index} - {new_vertex.index}\") for edge in d_concrete . edges : d_topology . add_edge ( edge . source , edge . target ) return d_topology @property def nodes ( self ) -> list [ igraph . Vertex ]: return list ( self . graph . vs ) def get_vertex_by_id ( self , vid : int ) -> igraph . Vertex : return self . graph . vs [ vid ] @property def edges ( self ) -> list [ igraph . Edge ]: return list ( self . graph . es ) @property def n_nodes ( self ) -> int : return len ( self . graph . vs ) def add_node ( self , c_type : CType ) -> igraph . Vertex : return self . graph . add_vertex ( c_type = c_type , label = c_type . id ) def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError def add_edge ( self , node_id_a : int , node_id_b : int ): self . graph . add_edge ( source = node_id_a , target = node_id_b ) def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError @property def components ( self ) -> set [ CType ]: if self . n_nodes > 0 : return set ( self . graph . vs ()[ \"c_type\" ]) return set () @property def edges ( self ) -> list [ igraph . Edge ]: return list ( self . graph . es ) def draw_random_node ( self ) -> igraph . Vertex | None : if self . n_nodes == 0 : return None return choice ( self . nodes ) def export ( self , file_type : ExportType ): absolute_folder = designs_folder / self . name if file_type == ExportType . TXT : save_to_file ( str ( self ), file_name = f \"DTopology\" , absolute_folder_path = absolute_folder , ) elif file_type == ExportType . JSON : raise Exception ( \"Can't create JSON from DTopology. It must be from DConcrete.\" ) elif file_type == ExportType . DOT : self . graph . write_dot ( f = str ( absolute_folder / \"topo_graph.dot\" )) else : raise Exception ( \"File type not supported\" ) print ( f \" { file_type } file saved in { absolute_folder } \" ) def __str__ ( self ): ret = str ( self . graph ) ret += \" \\n \" for node in self . nodes : ret += f \" { node . index } : { node [ 'c_type' ] } \\n \" return ret","title":"DTopology"},{"location":"reference/sym_cps/representation/design/topology/#sym_cps.representation.design.topology.DTopology.remove_edge","text":"TODO. Tip: self.graph.delete_edges Source code in sym_cps/representation/design/topology/__init__.py 68 69 70 def remove_edge ( self ): \"\"\"TODO. Tip: self.graph.delete_edges\"\"\" raise NotImplementedError","title":"remove_edge()"},{"location":"reference/sym_cps/representation/design/topology/#sym_cps.representation.design.topology.DTopology.remove_node","text":"TODO Source code in sym_cps/representation/design/topology/__init__.py 61 62 63 def remove_node ( self ): \"\"\"TODO\"\"\" raise NotImplementedError","title":"remove_node()"},{"location":"reference/sym_cps/representation/library/","text":"","title":"library"},{"location":"reference/sym_cps/representation/library/elements/","text":"","title":"elements"},{"location":"reference/sym_cps/representation/library/elements/c_connector/","text":"","title":"c_connector"},{"location":"reference/sym_cps/representation/library/elements/c_parameter/","text":"CParameter dataclass \u00b6 Indicates the possible values and type of a component parameter. Parameters are associated to component classes. Source code in sym_cps/representation/library/elements/c_parameter.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @dataclass ( frozen = True ) class CParameter : \"\"\"Indicates the possible values and type of a component parameter. Parameters are associated to component classes. \"\"\" name : str belongs_to : CType = field ( init = False ) _values : dict = field ( init = False , default_factory = dict ) def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) attr . update ( value ) object . __setattr__ ( self , name , attr ) def __post_init__ ( self ): vals : dict [ str , float | None ] = { \"min_val\" : None , \"max_val\" : None , \"default_val\" : None , \"assigned_val\" : None , } self . _edit_field ( \"_values\" , vals ) @property def values ( self ) -> dict [ str , float ]: \"\"\"Filters out None component\"\"\" return { key : value for key , value in self . _values . items () if value is not None } def _edit_values ( self , values : dict ): for key in values . keys (): if key in self . _values . keys (): if values [ key ] != \"\" : self . _values [ key ] = float ( values [ key ]) @property def id ( self ) -> str : \"\"\"Internal ID\"\"\" return parameter_id ( self . name , str ( self . belongs_to )) def __str__ ( self ): values = \", \" . join ([ f \" { k } : { v } \" for k , v in self . values . items ()]) return f \" { self . name } \\t { values } \" def __hash__ ( self ): return abs ( hash ( self . id )) id () property \u00b6 Internal ID Source code in sym_cps/representation/library/elements/c_parameter.py 52 53 54 55 @property def id ( self ) -> str : \"\"\"Internal ID\"\"\" return parameter_id ( self . name , str ( self . belongs_to )) values () property \u00b6 Filters out None component Source code in sym_cps/representation/library/elements/c_parameter.py 41 42 43 44 @property def values ( self ) -> dict [ str , float ]: \"\"\"Filters out None component\"\"\" return { key : value for key , value in self . _values . items () if value is not None }","title":"c_parameter"},{"location":"reference/sym_cps/representation/library/elements/c_parameter/#sym_cps.representation.library.elements.c_parameter.CParameter","text":"Indicates the possible values and type of a component parameter. Parameters are associated to component classes. Source code in sym_cps/representation/library/elements/c_parameter.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @dataclass ( frozen = True ) class CParameter : \"\"\"Indicates the possible values and type of a component parameter. Parameters are associated to component classes. \"\"\" name : str belongs_to : CType = field ( init = False ) _values : dict = field ( init = False , default_factory = dict ) def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) attr . update ( value ) object . __setattr__ ( self , name , attr ) def __post_init__ ( self ): vals : dict [ str , float | None ] = { \"min_val\" : None , \"max_val\" : None , \"default_val\" : None , \"assigned_val\" : None , } self . _edit_field ( \"_values\" , vals ) @property def values ( self ) -> dict [ str , float ]: \"\"\"Filters out None component\"\"\" return { key : value for key , value in self . _values . items () if value is not None } def _edit_values ( self , values : dict ): for key in values . keys (): if key in self . _values . keys (): if values [ key ] != \"\" : self . _values [ key ] = float ( values [ key ]) @property def id ( self ) -> str : \"\"\"Internal ID\"\"\" return parameter_id ( self . name , str ( self . belongs_to )) def __str__ ( self ): values = \", \" . join ([ f \" { k } : { v } \" for k , v in self . values . items ()]) return f \" { self . name } \\t { values } \" def __hash__ ( self ): return abs ( hash ( self . id ))","title":"CParameter"},{"location":"reference/sym_cps/representation/library/elements/c_parameter/#sym_cps.representation.library.elements.c_parameter.CParameter.id","text":"Internal ID Source code in sym_cps/representation/library/elements/c_parameter.py 52 53 54 55 @property def id ( self ) -> str : \"\"\"Internal ID\"\"\" return parameter_id ( self . name , str ( self . belongs_to ))","title":"id()"},{"location":"reference/sym_cps/representation/library/elements/c_parameter/#sym_cps.representation.library.elements.c_parameter.CParameter.values","text":"Filters out None component Source code in sym_cps/representation/library/elements/c_parameter.py 41 42 43 44 @property def values ( self ) -> dict [ str , float ]: \"\"\"Filters out None component\"\"\" return { key : value for key , value in self . _values . items () if value is not None }","title":"values()"},{"location":"reference/sym_cps/representation/library/elements/c_property/","text":"","title":"c_property"},{"location":"reference/sym_cps/representation/library/elements/c_type/","text":"CType dataclass \u00b6 Source code in sym_cps/representation/library/elements/c_type.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 @dataclass ( frozen = True ) class CType : id : str \"\"\"Configurable parameters\"\"\" parameters : dict [ str , CParameter ] = field ( init = False , default_factory = dict ) \"\"\"Accepted connectors\"\"\" connectors : dict [ str , CConnector ] = field ( init = False , default_factory = dict ) \"\"\"Compatible CType to be connected to\"\"\" compatible_with : dict [ str , CType ] = field ( init = False , default_factory = dict ) \"\"\"Library components of CType\"\"\" belongs_to : dict [ str , LibraryComponent ] = field ( init = False , default_factory = dict ) def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) if len ( attr ) == 0 : object . __setattr__ ( self , name , value ) return attr . update ( value ) object . __setattr__ ( self , name , attr ) def _remove_from_field ( self , name , value ): if value not in self . belongs_to . keys (): return attr = object . __getattribute__ ( self , name ) if len ( attr ) == 0 : return del attr [ value ] object . __setattr__ ( self , name , attr ) def __str__ ( self ) -> str : return self . id def __hash__ ( self ) -> int : return hash ( self . id ) compatible_with : dict [ str , CType ] = field ( init = False , default_factory = dict ) class-attribute \u00b6 Library components of CType connectors : dict [ str , CConnector ] = field ( init = False , default_factory = dict ) class-attribute \u00b6 Compatible CType to be connected to id : str class-attribute \u00b6 Configurable parameters parameters : dict [ str , CParameter ] = field ( init = False , default_factory = dict ) class-attribute \u00b6 Accepted connectors","title":"c_type"},{"location":"reference/sym_cps/representation/library/elements/c_type/#sym_cps.representation.library.elements.c_type.CType","text":"Source code in sym_cps/representation/library/elements/c_type.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 @dataclass ( frozen = True ) class CType : id : str \"\"\"Configurable parameters\"\"\" parameters : dict [ str , CParameter ] = field ( init = False , default_factory = dict ) \"\"\"Accepted connectors\"\"\" connectors : dict [ str , CConnector ] = field ( init = False , default_factory = dict ) \"\"\"Compatible CType to be connected to\"\"\" compatible_with : dict [ str , CType ] = field ( init = False , default_factory = dict ) \"\"\"Library components of CType\"\"\" belongs_to : dict [ str , LibraryComponent ] = field ( init = False , default_factory = dict ) def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) if len ( attr ) == 0 : object . __setattr__ ( self , name , value ) return attr . update ( value ) object . __setattr__ ( self , name , attr ) def _remove_from_field ( self , name , value ): if value not in self . belongs_to . keys (): return attr = object . __getattribute__ ( self , name ) if len ( attr ) == 0 : return del attr [ value ] object . __setattr__ ( self , name , attr ) def __str__ ( self ) -> str : return self . id def __hash__ ( self ) -> int : return hash ( self . id )","title":"CType"},{"location":"reference/sym_cps/representation/library/elements/c_type/#sym_cps.representation.library.elements.c_type.CType.compatible_with","text":"Library components of CType","title":"compatible_with"},{"location":"reference/sym_cps/representation/library/elements/c_type/#sym_cps.representation.library.elements.c_type.CType.connectors","text":"Compatible CType to be connected to","title":"connectors"},{"location":"reference/sym_cps/representation/library/elements/c_type/#sym_cps.representation.library.elements.c_type.CType.id","text":"Configurable parameters","title":"id"},{"location":"reference/sym_cps/representation/library/elements/c_type/#sym_cps.representation.library.elements.c_type.CType.parameters","text":"Accepted connectors","title":"parameters"},{"location":"reference/sym_cps/representation/library/elements/library_component/","text":"LibraryComponent dataclass \u00b6 Represent and model of component in the components_library. It has fixed properties and can have parameters and connectors. Source code in sym_cps/representation/library/elements/library_component.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @dataclass ( frozen = True ) class LibraryComponent : \"\"\"Represent and model of component in the components_library. It has fixed properties and can have parameters and connectors.\"\"\" \"\"\"Component Model Name\"\"\" id : str comp_type : CType properties : dict [ str , CProperty ] = field ( init = False , default_factory = dict ) @property def parameters ( self ) -> dict [ str , CParameter ]: return self . comp_type . parameters @property def connectors ( self ) -> dict [ str , CConnector ]: return self . comp_type . connectors def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) attr . update ( value ) object . __setattr__ ( self , name , attr ) def __hash__ ( self ): return hash ( str ( self . id )) def __str__ ( self ) -> str : s1 = f \"name: { self . id } \\n \" f \"type: { str ( self . comp_type ) } \\n \" properties_str = [] for e in list ( self . properties . values ()): properties_str . append ( tab ( e )) properties = \" \\n \" . join ( properties_str ) parameters_str = [] for e in list ( self . parameters . values ()): parameters_str . append ( tab ( e )) parameters = \" \\n \" . join ( parameters_str ) connectors_str = [] for e in list ( self . connectors . values ()): connectors_str . append ( tab ( e )) connectors = \" \\n \" . join ( connectors_str ) s2 = f \"properties: \\n { properties } \\n \" s3 = f \"connectors: \\n { connectors } \\n \" s4 = f \"parameters: \\n { parameters } \\n \" return s1 + s2 + s3 + s4","title":"library_component"},{"location":"reference/sym_cps/representation/library/elements/library_component/#sym_cps.representation.library.elements.library_component.LibraryComponent","text":"Represent and model of component in the components_library. It has fixed properties and can have parameters and connectors. Source code in sym_cps/representation/library/elements/library_component.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @dataclass ( frozen = True ) class LibraryComponent : \"\"\"Represent and model of component in the components_library. It has fixed properties and can have parameters and connectors.\"\"\" \"\"\"Component Model Name\"\"\" id : str comp_type : CType properties : dict [ str , CProperty ] = field ( init = False , default_factory = dict ) @property def parameters ( self ) -> dict [ str , CParameter ]: return self . comp_type . parameters @property def connectors ( self ) -> dict [ str , CConnector ]: return self . comp_type . connectors def _edit_field ( self , name , value ): object . __setattr__ ( self , name , value ) def _update_field ( self , name , value ): attr = object . __getattribute__ ( self , name ) attr . update ( value ) object . __setattr__ ( self , name , attr ) def __hash__ ( self ): return hash ( str ( self . id )) def __str__ ( self ) -> str : s1 = f \"name: { self . id } \\n \" f \"type: { str ( self . comp_type ) } \\n \" properties_str = [] for e in list ( self . properties . values ()): properties_str . append ( tab ( e )) properties = \" \\n \" . join ( properties_str ) parameters_str = [] for e in list ( self . parameters . values ()): parameters_str . append ( tab ( e )) parameters = \" \\n \" . join ( parameters_str ) connectors_str = [] for e in list ( self . connectors . values ()): connectors_str . append ( tab ( e )) connectors = \" \\n \" . join ( connectors_str ) s2 = f \"properties: \\n { properties } \\n \" s3 = f \"connectors: \\n { connectors } \\n \" s4 = f \"parameters: \\n { parameters } \\n \" return s1 + s2 + s3 + s4","title":"LibraryComponent"},{"location":"reference/sym_cps/representation/tools/","text":"","title":"tools"},{"location":"reference/sym_cps/representation/tools/analyze/","text":"","title":"analyze"},{"location":"reference/sym_cps/representation/tools/connectors/","text":"","title":"connectors"},{"location":"reference/sym_cps/representation/tools/ids/","text":"","title":"ids"},{"location":"reference/sym_cps/representation/tools/export/","text":"","title":"export"},{"location":"reference/sym_cps/representation/tools/export/design_swri/","text":"","title":"design_swri"},{"location":"reference/sym_cps/representation/tools/parsers/","text":"","title":"parsers"},{"location":"reference/sym_cps/representation/tools/parsers/learn_from_designs/","text":"","title":"learn_from_designs"},{"location":"reference/sym_cps/representation/tools/parsers/parse/","text":"parse_library_and_seed_designs () \u00b6 Generates a Components Library Source code in sym_cps/representation/tools/parsers/parse.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def parse_library_and_seed_designs () -> tuple [ Library , dict [ str , tuple [ DConcrete , DTopology ]] ]: \"\"\"Generates a Components Library\"\"\" c_library : Library = Library () . from_folder ( path = component_library_root_path_default ) \"\"\"Learn information form existing designs\"\"\" ( connectable_connectors , connectable_components_types , design_parameters , ) = parse_connections_and_parameters_from_designs ( design_library_root_path_default , library = c_library ) \"\"\"Update information to the library\"\"\" c_library . update_information ( connectable_connectors , connectable_components_types , design_parameters ) \"\"\"Load Seed Designs\"\"\" designs = parse_designs_from_folder ( design_library_root_path_default , library = c_library ) return c_library , designs","title":"parse"},{"location":"reference/sym_cps/representation/tools/parsers/parse/#sym_cps.representation.tools.parsers.parse.parse_library_and_seed_designs","text":"Generates a Components Library Source code in sym_cps/representation/tools/parsers/parse.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def parse_library_and_seed_designs () -> tuple [ Library , dict [ str , tuple [ DConcrete , DTopology ]] ]: \"\"\"Generates a Components Library\"\"\" c_library : Library = Library () . from_folder ( path = component_library_root_path_default ) \"\"\"Learn information form existing designs\"\"\" ( connectable_connectors , connectable_components_types , design_parameters , ) = parse_connections_and_parameters_from_designs ( design_library_root_path_default , library = c_library ) \"\"\"Update information to the library\"\"\" c_library . update_information ( connectable_connectors , connectable_components_types , design_parameters ) \"\"\"Load Seed Designs\"\"\" designs = parse_designs_from_folder ( design_library_root_path_default , library = c_library ) return c_library , designs","title":"parse_library_and_seed_designs()"},{"location":"reference/sym_cps/representation/tools/parsers/parsing_designs/","text":"parse_design_from_design_swri ( path , library ) \u00b6 Initialize a DConcrete from a design_swri file data Source code in sym_cps/representation/tools/parsers/parsing_designs.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 def parse_design_from_design_swri ( path : Path , library : Library ) -> DConcrete : \"\"\"Initialize a DConcrete from a design_swri file data\"\"\" \"\"\"Read design_swri file\"\"\" with open ( path , \"r\" ) as design_swri_file : design_swri_data = json . load ( design_swri_file ) \"\"\"Read the design name\"\"\" design_name = design_swri_data [ \"name\" ] new_design = DConcrete ( name = design_name ) \"\"\"Read the components and parameters\"\"\" # maps component instance name to library component component_map : dict [ str , tuple [ str , dict [ str , Parameter ]]] = {} for component_data in design_swri_data [ \"components\" ]: component_instance_str = component_data [ \"component_instance\" ] library_component_str = component_data [ \"component_choice\" ] component_map [ component_instance_str ] = ( library_component_str , {}) for parameter_data in design_swri_data [ \"parameters\" ]: parameter_name = parameter_data [ \"parameter_name\" ] parameter_value = parameter_data [ \"value\" ] component_properties = parameter_data [ \"component_properties\" ] parameters : dict [ str , Parameter ] = {} for prop in component_properties : component_name = prop [ \"component_name\" ] component_property = prop [ \"component_property\" ] library_component_str = component_map [ component_name ][ 0 ] param_id = parameter_id ( component_property , library . components [ library_component_str ] . comp_type . id ) for p , para in library . parameters . items (): print ( p ) try : param_type = library . parameters [ param_id ] except : print ( \"wasda\" ) param_type = library . parameters [ param_id ] parameter = Parameter ( parameter_value , param_type ) parameters [ param_id ] = parameter component_map [ component_name ][ 1 ][ param_id ] = parameter for p in parameters . values (): if isinstance ( p . component , str ): print ( \"ERRORRRR\" ) new_design . design_parameters [ parameter_name ] = DesignParameter ( id = parameter_name , parameters = set ( parameters . values ()) ) for component_name , ( library_component_str , parameters ) in component_map . items (): new_component = Component ( id = component_name , library_component = library . components [ library_component_str ], parameters = parameters , ) new_design . add_node ( new_component ) \"\"\"Read the connection\"\"\" for connection_data in design_swri_data [ \"connections\" ]: instance_s = connection_data [ \"from_ci\" ] instance_t = connection_data [ \"to_ci\" ] component_choice_s = component_map [ instance_s ][ 0 ] component_choice_t = component_map [ instance_t ][ 0 ] connector_id_s = connector_id ( name = connection_data [ \"from_conn\" ], component_type = str ( library . components [ component_choice_s ] . comp_type ), ) connector_id_t = connector_id ( name = connection_data [ \"to_conn\" ], component_type = str ( library . components [ component_choice_t ] . comp_type ), ) connection = Connection ( component_a = new_design . get_instance ( instance_s ), connector_a = library . connectors [ connector_id_s ], component_b = new_design . get_instance ( instance_t ), connector_b = library . connectors [ connector_id_t ], ) try : new_design . connect ( connection ) except : pass # d_concrete = new_design # d_topology = DTopology.from_concrete(new_design) \"\"\"TODO: Update connectable connectors\"\"\" # for key, value in connectable_connectors.items(): # for output_connector in value: # type: ignore # # print(f\"{key} -> {output_connector}\") # all_connectors[key]._update_field(\"compatible_with\", {all_connectors[output_connector].id: all_connectors[output_connector]}) return new_design","title":"parsing_designs"},{"location":"reference/sym_cps/representation/tools/parsers/parsing_designs/#sym_cps.representation.tools.parsers.parsing_designs.parse_design_from_design_swri","text":"Initialize a DConcrete from a design_swri file data Source code in sym_cps/representation/tools/parsers/parsing_designs.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 def parse_design_from_design_swri ( path : Path , library : Library ) -> DConcrete : \"\"\"Initialize a DConcrete from a design_swri file data\"\"\" \"\"\"Read design_swri file\"\"\" with open ( path , \"r\" ) as design_swri_file : design_swri_data = json . load ( design_swri_file ) \"\"\"Read the design name\"\"\" design_name = design_swri_data [ \"name\" ] new_design = DConcrete ( name = design_name ) \"\"\"Read the components and parameters\"\"\" # maps component instance name to library component component_map : dict [ str , tuple [ str , dict [ str , Parameter ]]] = {} for component_data in design_swri_data [ \"components\" ]: component_instance_str = component_data [ \"component_instance\" ] library_component_str = component_data [ \"component_choice\" ] component_map [ component_instance_str ] = ( library_component_str , {}) for parameter_data in design_swri_data [ \"parameters\" ]: parameter_name = parameter_data [ \"parameter_name\" ] parameter_value = parameter_data [ \"value\" ] component_properties = parameter_data [ \"component_properties\" ] parameters : dict [ str , Parameter ] = {} for prop in component_properties : component_name = prop [ \"component_name\" ] component_property = prop [ \"component_property\" ] library_component_str = component_map [ component_name ][ 0 ] param_id = parameter_id ( component_property , library . components [ library_component_str ] . comp_type . id ) for p , para in library . parameters . items (): print ( p ) try : param_type = library . parameters [ param_id ] except : print ( \"wasda\" ) param_type = library . parameters [ param_id ] parameter = Parameter ( parameter_value , param_type ) parameters [ param_id ] = parameter component_map [ component_name ][ 1 ][ param_id ] = parameter for p in parameters . values (): if isinstance ( p . component , str ): print ( \"ERRORRRR\" ) new_design . design_parameters [ parameter_name ] = DesignParameter ( id = parameter_name , parameters = set ( parameters . values ()) ) for component_name , ( library_component_str , parameters ) in component_map . items (): new_component = Component ( id = component_name , library_component = library . components [ library_component_str ], parameters = parameters , ) new_design . add_node ( new_component ) \"\"\"Read the connection\"\"\" for connection_data in design_swri_data [ \"connections\" ]: instance_s = connection_data [ \"from_ci\" ] instance_t = connection_data [ \"to_ci\" ] component_choice_s = component_map [ instance_s ][ 0 ] component_choice_t = component_map [ instance_t ][ 0 ] connector_id_s = connector_id ( name = connection_data [ \"from_conn\" ], component_type = str ( library . components [ component_choice_s ] . comp_type ), ) connector_id_t = connector_id ( name = connection_data [ \"to_conn\" ], component_type = str ( library . components [ component_choice_t ] . comp_type ), ) connection = Connection ( component_a = new_design . get_instance ( instance_s ), connector_a = library . connectors [ connector_id_s ], component_b = new_design . get_instance ( instance_t ), connector_b = library . connectors [ connector_id_t ], ) try : new_design . connect ( connection ) except : pass # d_concrete = new_design # d_topology = DTopology.from_concrete(new_design) \"\"\"TODO: Update connectable connectors\"\"\" # for key, value in connectable_connectors.items(): # for output_connector in value: # type: ignore # # print(f\"{key} -> {output_connector}\") # all_connectors[key]._update_field(\"compatible_with\", {all_connectors[output_connector].id: all_connectors[output_connector]}) return new_design","title":"parse_design_from_design_swri()"},{"location":"reference/sym_cps/representation/tools/parsers/parsing_library/","text":"parse_parameter_bounds () \u00b6 Parse design expert parameter bounds from 'lower_bound_file' 'lower_bound_file' Source code in sym_cps/representation/tools/parsers/parsing_library.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def parse_parameter_bounds () -> None : \"\"\"Parse design expert parameter bounds from 'lower_bound_file' 'lower_bound_file'\"\"\" if len ( all_parameters_lower_bounds ) == 0 : file = open ( lower_bound_file , \"r\" ) for line in file : k , v = line . strip () . split ( \":\" ) all_parameters_lower_bounds [ k . strip ()] = float ( v . strip ()) if len ( all_parameters_upper_bounds ) == 0 : file = open ( upper_bound_file , \"r\" ) for line in file : k , v = line . strip () . split ( \":\" ) all_parameters_upper_bounds [ k . strip ()] = float ( v . strip ())","title":"parsing_library"},{"location":"reference/sym_cps/representation/tools/parsers/parsing_library/#sym_cps.representation.tools.parsers.parsing_library.parse_parameter_bounds","text":"Parse design expert parameter bounds from 'lower_bound_file' 'lower_bound_file' Source code in sym_cps/representation/tools/parsers/parsing_library.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def parse_parameter_bounds () -> None : \"\"\"Parse design expert parameter bounds from 'lower_bound_file' 'lower_bound_file'\"\"\" if len ( all_parameters_lower_bounds ) == 0 : file = open ( lower_bound_file , \"r\" ) for line in file : k , v = line . strip () . split ( \":\" ) all_parameters_lower_bounds [ k . strip ()] = float ( v . strip ()) if len ( all_parameters_upper_bounds ) == 0 : file = open ( upper_bound_file , \"r\" ) for line in file : k , v = line . strip () . split ( \":\" ) all_parameters_upper_bounds [ k . strip ()] = float ( v . strip ())","title":"parse_parameter_bounds()"},{"location":"reference/sym_cps/representation/tools/parsers/temp_objects/","text":"","title":"temp_objects"},{"location":"reference/sym_cps/shared/","text":"","title":"shared"},{"location":"reference/sym_cps/shared/paths/","text":"","title":"paths"},{"location":"reference/sym_cps/tools/","text":"","title":"tools"},{"location":"reference/sym_cps/tools/io/","text":"","title":"io"},{"location":"reference/sym_cps/tools/persistance/","text":"","title":"persistance"},{"location":"reference/sym_cps/tools/strings/","text":"","title":"strings"},{"location":"coverage/","text":".md-content { max-width: none !important; } article h1, article > a { display: none; } var coviframe = document.getElementById(\"coviframe\"); function resizeIframe() { coviframe.style.height = coviframe.contentWindow.document.documentElement.offsetHeight + 'px'; } coviframe.contentWindow.document.body.onclick = function() { coviframe.contentWindow.location.reload(); }","title":"Coverage report"}]}